<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>瞎捣鼓的废宅</title>
  <icon>https://www.gravatar.com/avatar/ef3b32cb12d3c073cf5aa79e7c76009c</icon>
  <subtitle>徘徊于虚幻与现实</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-26T12:27:10.365Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>colorcat</name>
    <email>color_cat@126.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图像处理基础学习笔记——OpenCV常用API汇总</title>
    <link href="http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/</id>
    <published>2020-07-12T06:49:52.000Z</published>
    <updated>2020-07-26T12:27:10.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明">说明</h2><p>这篇博客只用来记录目前我已经接触过的API，只涉及用法及效果，不涉及背后算法，具体算法我会在其他的博客中进行介绍。随着逐渐学习，我也会对这篇博客进行动态更新，有些内容缺少的就是我也还没弄懂的。</p><p>并不会详细解释API，更适合有一定经验的人查阅。</p><p>我也只是个初学者，很多内容都是跟着教程的框架进行学习，如果内容上有错误欢迎大家指正与补充。</p><hr><h2 id="基础操作">基础操作</h2><h3 id="读入">读入</h3><h4 id="图片">图片</h4><p><kbd>imread()</kbd>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat imread( const String&amp; filename, int flags &#x3D; IMREAD_COLOR );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是图片路径</p><p>第二个参数是读入色彩模式</p><p>常用的模式：</p><p>IMREAD_UNCHANGED 按图片原色彩模式读入</p><p>IMREAD_GRAYSCALE 按灰度图读入</p><p>IMREAD_COLOR 按BGR彩色读入</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat demo;</span><br><span class="line">demo &#x3D; imread(&quot;F:&#x2F;&#x2F;opencv file&#x2F;picture.jpg&quot; , IMREAD_UNCHANGED);</span><br></pre></td></tr></table></figure><h4 id="视频或摄像头">视频或摄像头</h4><p><kbd>VideoCapture</kbd>类</p><p>使用样例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VideoCapture cap;</span><br><span class="line">cap.open(0); &#x2F;&#x2F; cap.open(&quot;F:\\opencv file&#x2F;测试视频.mp4&quot;);</span><br><span class="line">&#x2F;&#x2F;以上等价于 VideoCaputure cap(0);</span><br><span class="line">Mat demo;</span><br><span class="line">while(1)&#123;</span><br><span class="line">cap&gt;&gt;demo</span><br><span class="line">imshow(&quot;demo&quot;,demo);</span><br><span class="line">waitKey(30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建一个<kbd>VideoCapture</kbd>通过<kbd>open</kbd>可以打开摄像头或者视频,摄像头的话是使用摄像头的index号，笔记本摄像头默认为0。视频是使用路径。</p><p>然后用<kbd>&gt;&gt;</kbd>读入到<kbd>Mat</kbd>中进行处理，循环输出。</p><p><kbd>VideoCapture</kbd>还有一些常用的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap.get(CV_CAP_PROP_FRAME_WIDTH) &#x2F;&#x2F;帧宽度</span><br><span class="line">cap.get(CV_CAP_PROP_FRAME_HEIGHT) &#x2F;&#x2F;帧高度</span><br><span class="line">cap.get(CV_CAP_PROP_FPS);  &#x2F;&#x2F;帧率 x frames&#x2F;s</span><br><span class="line">cap.get(CV_CAP_PROP_FRAME_COUNT); &#x2F;&#x2F;总帧数</span><br></pre></td></tr></table></figure><h3 id="输出">输出</h3><h4 id="图片-2">图片</h4><p><kbd>imwrite()</kbd>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imwrite( const String&amp; filename, InputArray img,const std::vector&lt;int&gt;&amp; params &#x3D; std::vector&lt;int&gt;());</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输出的文件路径</p><p>第二个参数是要输出的图片</p></blockquote><h4 id="视频">视频</h4><p><kbd>VideoWriter</kbd>类</p><blockquote><p>这部分我还没倒腾明白，之后用到的时候再补齐</p></blockquote><h3 id="颜色">颜色</h3><p><kbd>Scalar</kbd>对象与函数</p><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scalar color &#x3D; Scalar(255,255,255) &#x2F;&#x2F;设置色彩为白色</span><br></pre></td></tr></table></figure><h3 id="随机数（随机色彩）">随机数（随机色彩）</h3><p><kbd>RNG</kbd>类</p><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RNG rng((unsigned)time(NULL));&#x2F;&#x2F;声明时需要设定一个种子，一般会设置为当前时间，可以保证每次的种子都不同。</span><br><span class="line">int i &#x3D; rng.uniform(0,255)&#x2F;&#x2F;uniform(a,b),可以生成[a,b)之间的随机数，返回值与输入的范围值相同，也可以用强制转换得到多种数据类型</span><br></pre></td></tr></table></figure><h3 id="像素范围处理">像素范围处理</h3><p><kbd>saturate_cast()</kbd>函数</p><p>用于使数值不超过数据类型允许范围</p><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(400)&#x2F;&#x2F;返回255</span><br><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(-100)&#x2F;&#x2F;返回0</span><br><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(100)&#x2F;&#x2F;返回100</span><br></pre></td></tr></table></figure><h3 id="色彩转换">色彩转换</h3><p><kbd>cvtColor()</kbd>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cvtColor( InputArray src, OutputArray dst, int code, int dstCn &#x3D; 0 );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是转换模式</p><p>常用的有：</p><p>CV_BGR2GRAY//BGR转灰度</p><p>CV_BGR2HSV //BGR转HSV</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvtColor(demo,demo,CV_BGR2GRAY);  &#x2F;&#x2F;从BGR彩色图转换为灰度图</span><br></pre></td></tr></table></figure><p>形态学操作、直方图、边缘检测等API需要输入单通道的图，就可以将彩色图转换为单通道的灰度图，也可以选择将不同的通道分为不同的图像。</p><h3 id="通道分离">通道分离</h3><p>将多通道的彩色图像，分为多个单通道的图。</p><p><kbd>split()</kbd>函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void split(const Mat&amp; src, Mat* mvbegin)</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入Mat对象地址</p><p>第二个参数是分通道输出的Mat对象数组</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat dst[3];&#x2F;&#x2F;声明Mat对象数组</span><br><span class="line">split(demo,dst);&#x2F;&#x2F;将demo对象的三个通道分别赋给dst数组</span><br></pre></td></tr></table></figure><p>要注意分离后的图像都是单通道，直接显示都是灰度图。</p><h3 id="通道合并">通道合并</h3><p>将多个单通道图像合并为一个多通道的图像</p><p><kbd>merge()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void merge(InputArrayOfArrays mv, OutputArray dst);</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的多个单通道矩阵/图像的阵列，必须有相同深度和尺寸</p><p>第二个参数是合并后的矩阵/图像，通道数需要与参数一中的个数一致</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Mat&gt; channels;&#x2F;&#x2F;用于储存分离后的通道</span><br><span class="line">split(image_src, channels);&#x2F;&#x2F;分离通道</span><br><span class="line">merge(channels, image_dst);&#x2F;&#x2F;合并通道</span><br></pre></td></tr></table></figure><p>该函数是上边<kbd>split()</kbd>的逆操作，参数也类似。</p><h3 id="图像线性混合">图像线性混合</h3><p><kbd>addWeighted()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWeighted(InputArray src1, double alpha, InputArray src2,double beta, double gamma, OutputArray dst, int dtype &#x3D; -1);</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像1</p><p>第二个参数是图像1所占的比例</p><p>第三个参数是输入图像2</p><p>第四个参数是图像2所占的比例</p><p>第五个参数是偏差值，用0就可以</p><p>第六个参数是输出图像</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWeighted(image1, 0.4 , image2 , 0.6 , 0 , image_out);</span><br></pre></td></tr></table></figure><h3 id="图像线性运算">图像线性运算</h3><p><kbd>cvConvertScale()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvConvertScale( const CvArr* src, CvArr* dst, double scale ,double shift  );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入矩阵</p><p>第二个参数是输出矩阵</p><p>第三个参数是乘数因子</p><p>第四个参数是加权值</p><p>最后结果是输入矩阵中的每个元素   乘以乘数加上加权值  得到输出矩阵</p></blockquote><p><kbd>cvConvertScaleAbs()</kbd>函数</p><p>参数与上边的API一致，区别是这个API输出时会取绝对值。</p><h3 id="归一化">归一化</h3><p><kbd>normalize()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void normalize(InputArray src, InputOutputArray dst, double alpha&#x3D;1, double beta&#x3D;0, int norm_type&#x3D;NORM_L2, int dtype&#x3D;-1, InputArray mask&#x3D;noArray() )</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入数组/图像</p><p>第二个参数是输出数组/图像</p><p>第三个参数是用来规范值或者规范范围，并且是下限。</p><p>第四个参数是用来规范范围并且是上限只对NORM_MINMAX有效</p><p>第五个参数是归一化的模式</p><blockquote><p>归一到（min，max）范围内：NORM_MINMAX最小值为0，最大值为1，其他数根据比例计算</p><p>根据切比雪夫距离归一：NORM_INF最大值为1，其他数除以最大值</p><p>根据曼哈顿距离归一：NORM_L1每个数除以所有数和（绝对值）</p><p>根据欧几里得距离归一：NORM_L2 每个数除以所有数平方和的开方</p></blockquote></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;double&gt;demo &#x3D; &#123;10,17,20&#125;;</span><br><span class="line">normalize(demo,demo, 1 , 255 ,NORM_L1);</span><br></pre></td></tr></table></figure><hr><h2 id="画线与图形">画线与图形</h2><h3 id="线">线</h3><p><kbd>line()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color,int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的图像</p><p>第二个参数是线段起始点</p><p>第三个参数是线段结束点</p><p>第四个参数是线段颜色</p><p>第五个参数是线段宽度</p><p>第六个参数是线形</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">line(image , Point(50,50) , Point(100,100) , Scalar(255,0,0) , 3 , LINE_8);</span><br></pre></td></tr></table></figure><h3 id="矩形">矩形</h3><p><kbd>rectangle()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rectangle(InputOutputArray img, Point pt1, Point pt2,const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure><blockquote><p>与上边划线类似，第一个点是矩形左上角，第二个点是矩形右下角</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rectangle(image , Point(50,50) , Point(100,100) , Scalar(255,0,0) , 3 , LINE_8);</span><br></pre></td></tr></table></figure><h3 id="圆形">圆形</h3><p><kbd>circle()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void circle(InputOutputArray img, Point center, int radius, const Scalar&amp; color, int thickness &#x3D; 1,int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是圆心坐标</p><p>第三个参数是半径</p><p>第四个参数是颜色</p><p>第五个参数是线宽</p><p>第六个参数是线形</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">circle(image, Point(50,50) , 20 , Scalar(255,0,0) , 2 , LINE_8);</span><br></pre></td></tr></table></figure><h3 id="椭圆">椭圆</h3><p><kbd>ellipse()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ellipse(InputOutputArray img, Point center, Size axes,</span><br><span class="line">double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness &#x3D; 1,int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是椭圆中心点</p><p>第三个参数是椭圆的大小（姑且可以认为是可以框住椭圆的矩形尺寸，可以以此确定椭圆的长轴与短轴长度）</p><p>第四个参数是椭圆沿逆时针方向旋转的角度</p><p>第五、六个参数分别是椭圆开始的角度以及结束的角度（用于画带缺口的椭圆线，角度沿长轴顺时针方向）</p><p>第七个参数是颜色</p><p>第八个参数是线宽</p><p>第九个参数是线形</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ellipse(image , Point(100,100) , Size(30,60) , 30 , 0 , 180 , Scalar(255,0,0) , 2 , LINE_8);</span><br></pre></td></tr></table></figure><h3 id="多边形或折线">多边形或折线</h3><p><kbd>polylines()</kbd>函数</p><p>支持一次性画多个多边形</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void polylines(Mat&amp; img, const Point* const* pts, const int* npts,int ncontours, bool isClosed, const Scalar&amp; color,int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0 );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是画布图像</p><p>第二个参数是顶点数组，由于该函数支持同时画多个多边形，所以顶点数组是二维数组，且要将每个数组的头地址再装进一个一维数组中，这里的参数只用最后的一维数组</p><p>第三个参数是顶点数量，也是为了画多个图形，所以需要用数组的形式储存顶点数量</p><p>第四个参数是多边形的数量</p><p>第五个参数是折线是否闭合，真或假</p><p>后边的就是颜色、线型之类的了</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Point points[2][3];</span><br><span class="line">points[0][0] &#x3D; Point(50,50);</span><br><span class="line">points[0][1] &#x3D; Point(20,50);</span><br><span class="line">points[0][2] &#x3D; Point(30,40);</span><br><span class="line">points[1][0] &#x3D; Point(60,50);</span><br><span class="line">points[1][1] &#x3D; Point(50,80);</span><br><span class="line">points[1][2] &#x3D; Point(40,30);</span><br><span class="line">const Point* ptr[]&#x3D;&#123;points[0] , points[1]&#125;;</span><br><span class="line">int npts[] &#x3D; &#123;3,3&#125;;</span><br><span class="line">polylines(image , ptr , npts , 2 , ture , Scalar(255,0,0) , 2, LINE_8);</span><br></pre></td></tr></table></figure><p><kbd>fillPoly()</kbd>函数</p><p>该函数参数与<kbd>polylines</kbd>基本一致，区别是该函数是实心多边形，<kbd>polylines</kbd>只是边框</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fillPoly(Mat&amp; img, const Point** pts,const int* npts, int ncontours,const Scalar&amp; color, int lineType &#x3D; LINE_8, int shift &#x3D; 0, Point offset &#x3D; Point() );</span><br></pre></td></tr></table></figure><blockquote><p>和上边很相似，基本只需要五个参数，输入图像，顶点数组，顶点数量，图形数量，填充颜色</p></blockquote><h3 id="文字">文字</h3><p><kbd>putText()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void putText( InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color,</span><br><span class="line">int thickness &#x3D; 1, int lineType &#x3D; LINE_8,bool bottomLeftOrigin &#x3D; false );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是要输出的字符串</p><p>第三个参数是文本框左下角的坐标</p><p>第四个参数是字体</p><p>第五个参数是尺寸</p><p>第六个参数是颜色</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">putText(image , &quot;Hello world&quot; , Point(50,50) , FONT_HERSHEY_COMPLEX , 2 , Scalar(255,0,0));</span><br></pre></td></tr></table></figure><hr><h2 id="点操作">点操作</h2><ol><li><kbd>at</kbd>方法</li></ol><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uchar value &#x3D; image.at&lt;uchar&gt;(i,j);&#x2F;&#x2F;获得单通道图像i行j列像素点的值</span><br><span class="line">image.at&lt;uchar&gt;(i,j) &#x3D; 255;&#x2F;&#x2F;单通道图像赋值操作</span><br><span class="line">uchar value &#x3D; image.at&lt;Vec3b&gt;(i,j)[0];&#x2F;&#x2F;取出三通道图像i行j列像素点的第一个通道数值。</span><br><span class="line">Vec3b pixel &#x3D; image.at&lt;Vec3b&gt;(i,j);&#x2F;&#x2F;将三通道图像i行j列像素点数组赋给pixel</span><br></pre></td></tr></table></figure><p>需要注意对遍历多通道图像时使用<em>像素点数组</em>进行操作时，列数为<strong>像素点的列数</strong>（及图像列数）。直接获取<em>单通道数值</em>进行操作时，列数为<strong>像素点的列数*通道数</strong>。</p><p><kbd>at</kbd>函数可读性高，但效率不高，不适合用来遍历图像。</p><ol start="2"><li><kbd>ptr</kbd>方法</li></ol><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uchar* date_in &#x3D; image_in.ptr&lt;uchar&gt;(i);&#x2F;&#x2F;获取图像第i行像素值的指针,设置为常量是为了保证原图不变，保留副本。</span><br><span class="line">uchar* date_out &#x3D; image_out.ptr&lt;uchar&gt;(i);</span><br><span class="line">date_out[j] &#x3D; date_in[j];&#x2F;&#x2F;复制像素</span><br></pre></td></tr></table></figure><p>需要特别注意，这里是将一行的数据装进数组，也就意味着对于通道的图，一行数据一共有<strong>图像列数*通道数</strong>个。如果要对单一通道进行操作，遍历时每次应该向下移动<strong>通道数</strong>个数据。</p><p>以这种方法遍历，效率更高。</p><p><strong>遍历时，单点像素乘以常数可以调整对比度，加减常数可以调整亮度。</strong></p><h2 id="卷积操作">卷积操作</h2><h3 id="卷积核">卷积核</h3><p>想要进行卷积运算需要先定义一个卷积核。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat kernel &#x3D; (Mat_&lt;uchar&gt;(3,3) &lt;&lt; 0,1,0,1,-4,1,0,1,0);</span><br></pre></td></tr></table></figure><p>上式创建的掩膜为：</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">-4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>该卷积核可以用来提高对比度。又被成为<strong>拉普拉斯算子</strong></p><p><strong>sobel算子</strong>，可以用于检测边缘<br>检测横向边缘：</p><table><thead><tr><th>-1</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>-2</td><td>0</td><td>2</td></tr><tr><td>-1</td><td>0</td><td>1</td></tr></tbody></table><p>检测纵向边缘</p><table><thead><tr><th>-1</th><th>-2</th><th>-1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>2</td><td>1</td></tr></tbody></table><h3 id="卷积">卷积</h3><p><kbd>filter2D()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void filter2D( InputArray src, OutputArray dst, int ddepth,InputArray kernel, Point anchor &#x3D; Point(-1,-1),double delta &#x3D; 0, int borderType &#x3D; BORDER_DEFAULT )</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是图像深度, -1 代表与输入图像一致</p><p>第四个参数是卷积核</p><p>第五个参数是锚点</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter2D(image_in,image_out,-1,kernel);&#x2F;&#x2F;使用kernel为卷积核输出image_out</span><br></pre></td></tr></table></figure><h3 id="模糊">模糊</h3><h4 id="均值模糊-均值滤波">均值模糊/均值滤波</h4><p><kbd>blur()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void blur( InputArray src, OutputArray dst,Size ksize, Point anchor &#x3D; Point(-1,-1),int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是均值模糊卷积核的大小，全方向模糊一般取3*3或5*5，也可以去单列或者单行的大小以进行单方向的模糊。要注意这个尺寸要确保有中心点存在。（2*2就不存在绝对的中心点）</p><p>第四个参数是锚点，默认位卷积核中心</p><p>第五个是边缘处理模式，一般用默认</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blur(image_in , image_out , Size(3,3));</span><br></pre></td></tr></table></figure><p>均值模糊无法保留边缘特征，只能整体模糊。</p><h4 id="中值模糊-中值滤波">中值模糊/中值滤波</h4><p><kbd>medianBlur()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void medianBlur( InputArray src, OutputArray dst, int ksize );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是卷积核的大小，固定是正方形，所以只取数字就可以，9就代表9*9的范围</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medianBlur(image_in , image_out , 3);</span><br></pre></td></tr></table></figure><p>中值滤波很适合去除椒盐噪声。</p><h4 id="高斯模糊-高斯滤波">高斯模糊/高斯滤波</h4><h5 id="高斯">高斯</h5><p><kbd>GaussianBlur()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GaussianBlur( InputArray src, OutputArray dst, Size ksize,double sigmaX, double sigmaY &#x3D; 0,int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是卷积核的大小</p><p>第四个参数是x方向上的标准偏差</p><p>第五个参数是y方向上的标准偏差</p><p>第六个参数是边缘处理模式</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GaussianBlur(image_in , image_out , Size(3,3) , 0.5 , 0.5);</span><br></pre></td></tr></table></figure><p>这种高斯模糊相较于均值模糊可以保留更多细节，但对边缘的保留一样效果不太好。</p><h5 id="双边高斯">双边高斯</h5><p><kbd>bilateralFilter()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bilateralFilter( InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace,int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是过滤器的大小，太大的话会影响速度</p><p>第四个参数是色彩空间的sigma，大一点可以提高模糊效果</p><p>第五个参数是坐标空间的sigma，小一点可以提高边缘保留效果</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bilateralFilter(image_in , image_out , 5 , 150 , 3);</span><br></pre></td></tr></table></figure><p>模糊效果不错，而且可以保留边缘，对人脸处理时，有类似于磨皮的效果。</p><hr><h2 id="形态学操作">形态学操作</h2><h3 id="结构体">结构体</h3><p><kbd>getStructuringElement()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat getStructuringElement(int shape, Size ksize, Point anchor &#x3D; Point(-1,-1));</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是结构体的形状</p><p>预设的形状有：MORPH_RECT 矩形  MORPH_CROSS 十字 MORPH_ELLIPSE 椭圆形</p><p>第二个参数是结构体的大小</p><p>第三个参数是锚点位置</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat kernel &#x3D; getStructuringElement(MORPH_RECT , Size(3,3));</span><br></pre></td></tr></table></figure><h3 id="运算">运算</h3><p><kbd>morphologyEx()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void morphologyEx( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,int borderType &#x3D; BORDER_CONSTANT,const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是操作模式</p><blockquote><p>操作模式有：</p><p>膨胀：MORPH_DILATE锚点处像素值取结构体覆盖下的最大值  扩大亮处</p><p>腐蚀：MORPH_ERODE锚点处像素值取结构体覆盖下的最小值  扩大暗处</p><p>开运算：MORPH_OPEN先腐蚀再膨胀 去掉小亮斑</p><p>闭运算： MORPH_CLOSE先膨胀再腐蚀    去掉小暗斑</p><p>顶帽： MORPH_TOPHAT 原图像与开运算后的结果求差可以观察开运算去除了哪些物体</p><p>黑帽： MORPH_BLACKHAT原图像与闭运算后的结果求差可以观察闭运算的效果</p><p>形态学梯度：MORPH_GRADIENT膨胀后的图减去腐蚀后的图可以得到图像大致的边缘</p></blockquote><p>第四个参数是结构体</p></blockquote><h3 id="检测直线-字符">检测直线/字符</h3><p>通过合理设置结构体，再经过开运算就可以检测直线或者字符</p><p>检测水平直线，就设置单行较长的结构体</p><p>检测竖直直线，就设置单列较长的结构体</p><p>检测较粗字符，可以设置正方形的结构体</p><hr><h2 id="阈值">阈值</h2><h3 id="阈值操作">阈值操作</h3><p><kbd>threshold()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threshold( InputArray src, OutputArray dst,double thresh, double maxval, int type );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是阈值</p><p>第四个参数是最大值</p><p>第五个参数是操作模式</p><blockquote><p>操作模式有：</p><p>二值化：THRESH_BINARY 大于阈值为最大，小于阈值为0</p><p>反二值化： THRESH_BINARY_INV大于阈值为0，小于阈值为最大</p><p>截断： THRESH_TRUNC大于阈值的限制为阈值，小于阈值的保持不变</p><p>取零： THRESH_TOZERO大于阈值的不变，小于阈值的为0</p><p>反取零： THRESH_TOZERO_INV大于阈值的为0，小于阈值的不变</p><p>最大类间方差： THRESH_OTSU通过统计学计算阈值，常用于分离物体与背景</p><p>自适应阈值： THRESH_TRIANGLE根据不同区域自行计算阈值，更多时候用另一个API实现</p></blockquote></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threshold(image_in , image_out , 150 , 255 , THRESH_TOZERO);</span><br></pre></td></tr></table></figure><p><kbd>adaptiveThreshold()</kbd>函数</p><p>自适应阈值操作</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void adaptiveThreshold( InputArray src, OutputArray dst,double maxValue, int adaptiveMethod,int thresholdType, int blockSize, double C );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是最大值</p><p>第四个参数是自适应类型</p><blockquote><p>平均值：ADAPTIVE_THRESH_MEAN_C 邻域像素平均值减去C作为阈值</p><p>高斯值：ADAPTIVE_THRESH_GAUSSIAN_C邻域像素通过高斯加权平均减去C，sigma值取决与邻域大小</p></blockquote><p>第五个参数是阈值操作模式，只能是THRESH_BINARY或者THRESH_BINARY_INV</p><p>第六个参数是计算阈值的邻域大小，3，5，7之类的</p><p>第七个参数是偏差值，可以设为0</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adaptiveThreshold(image_in , image_out , 255 , ADAPTIVE_THRESH_MEAN_C , THRESH_BINARY , 3 , 0);</span><br></pre></td></tr></table></figure><p>合理的设置阈值可以分离物体与背景，也可以用于获得物体的大致边缘。</p><h3 id="边缘检测">边缘检测</h3><p><kbd>Canny()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Canny( InputArray image, OutputArray edges,double threshold1, double threshold2, int apertureSize &#x3D; 3, bool L2gradient &#x3D; false );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出图像</p><p>第三个参数是阈值1低于这个阈值的点被认为不是边缘</p><p>第四个参数是阈值2高于这个阈值的点被认为是边缘，处于1与2之间的点会检测是否与边缘点接触，若接触则为边缘点</p><p>第五个参数是邻域范围</p><p>第六个参数是 是否使用更加精确的计算方法</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Canny(image_in , image_out , 100 , 200 , 3 , ture);</span><br></pre></td></tr></table></figure><p>使用Canny前，要先进行滤波，提高效果</p><hr><h2 id="霍夫变换">霍夫变换</h2><h3 id="直线">直线</h3><p><kbd>HoughLinesP()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HoughLinesP( InputArray image, OutputArray lines,double rho, double theta, int threshold,double minLineLength &#x3D; 0, double maxLineGap &#x3D; 0 );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出的直线两个端点坐标</p><p>第三个参数是极坐标中像素的扫描步长</p><p>第四个参数是极坐标中角度的扫描步长，一般取 CV_PI/180 也就是一度</p><p>第五个参数是阈值，极坐标系中至少要多少个函数相交才会看作直线</p><p>第六个参数是直线的最小长度</p><p>第七个参数是直线延伸过程中最大的间隔</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Vec4f&gt; plines ;&#x2F;&#x2F;设置一个向量用于存放输出</span><br><span class="line">HoughLinesP(image_in , plines , 1 , CV_PI&#x2F;180 , 20 , 50 , 5);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; plines.size(); i++)&#x2F;&#x2F;划出直线</span><br><span class="line">&#123;</span><br><span class="line">Vec4f point &#x3D; plines[i];&#x2F;&#x2F;取出第i个直线的端点数据，四个数据依次为，x0,y0,x1,y1</span><br><span class="line">line(image_out, Point(point[0], point[1]), Point(point[2], point[3]), Scalar(255, 255, 0), 2, LINE_AA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要先进行Canny边缘检测再进行霍夫直线检测</p><h3 id="圆">圆</h3><p><kbd>HoughCircles()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HoughCircles( InputArray image, OutputArray circles,int method, double dp, double minDist, double param1 &#x3D; 100, double param2 &#x3D; 100,int minRadius &#x3D; 0, int maxRadius &#x3D; 0 );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像</p><p>第二个参数是输出数据</p><p>第三个参数是检测方法，只有CV_HOUGH_GRADIENT</p><p>第四个参数设为1</p><p>第五个参数是两个圆心之间的最小距离</p><p>第六个参数是Canny检测时的高阈值，低阈值默认为高阈值的一半</p><p>第七个参数是圆心的阈值，在极坐标系中至少多少个函数的交点会被认为是圆心</p><p>第八个参数是圆的最小半径</p><p>第九个参数是圆的最大半径</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Vec3f&gt; pcircles;&#x2F;&#x2F;设置一个向量存储输出数据</span><br><span class="line">HoughCircles(image_in , pcircles , CV_HOUGH_GRADIENT , 1 , 100 , 120 , 50 , 100 , 200);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; pcircles.size(); i++)&#x2F;&#x2F;画出所有的圆，输出的数据中三个数据依次为x0,y0,r</span><br><span class="line">&#123;</span><br><span class="line">Vec3f circles &#x3D; pcircles[i];</span><br><span class="line">circle(dst,Point(circles[0],circles[1]),circles[2],Scalar(0,0,255),1,LINE_AA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>霍夫圆很容易受到椒盐噪声的影响，最好先进行中值滤波</p><hr><h2 id="直方图">直方图</h2><h3 id="直方图计算">直方图计算</h3><p><kbd>calcHist()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void calcHist( const Mat* images, int nimages,const int* channels, InputArray mask,SparseMat&amp; hist, int dims,const int* histSize, const float** ranges,bool uniform &#x3D; true, bool accumulate &#x3D; false );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的图像数组，也可以是单一图像的指针</p><p>第二个参数是图像的个数</p><p>第三个参数是通道数的地址，需要计算的通道的下标，可以传入一个数组，如果是单通道就是只有0的数组。</p><p>第四个参数是掩膜，如果有的话就是只计算掩膜上非零位置，不使用的话可以输cv::Mat()</p><p>第五个参数是输出的直方图数据</p><p>第六个参数是直方图的维度，一般来说取1</p><p>第七个参数是每一维上直方图个数的指针，一般来说越大直方图越精细</p><p>第八个参数是要统计的灰度范围，用一维float数组装入最小值与最大值，再装入一个常量float指针数组。</p><p>第九个参数是是否归一化，默认开启</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int channels &#x3D; 0;&#x2F;&#x2F;设置通道数</span><br><span class="line">float range[] &#x3D; &#123;0,256&#125;;&#x2F;&#x2F;将最小值与最大值存入一维float数组</span><br><span class="line">const float* histrange[] &#x3D; &#123;range&#125;;&#x2F;&#x2F;将一维数组装入常量float指针数组</span><br><span class="line">int hist_size &#x3D; 200;&#x2F;&#x2F;一共200个直方图</span><br><span class="line">calcHist(image_in , 1 , &amp;channels , Mat() , hist , 1 , &amp;hist_size , histrange);&#x2F;&#x2F;将直方图数据存入hist</span><br><span class="line">normalize(hist , hist , 0 , image_out.rows , NORM_MINMIX);&#x2F;&#x2F;进行归一化</span><br><span class="line">double bin_w &#x3D; (double)image_out.rows&#x2F;hist_size;</span><br><span class="line">for (int i &#x3D; 1; i &lt; hist_size; i++)</span><br><span class="line">&#123;</span><br><span class="line">line(image_out , Point((i-1)*bin_w , image_out.rows - cvRound(hist.at&lt;float&gt;(i-1))) , Point(i*bin_w , image_out.rows - cvRound(hist.at&lt;float&gt;(i))) , Scalar(255,0,0) , 2 , LINE_AA);</span><br><span class="line">&#125; &#x2F;&#x2F;cvRound是四舍五入取整</span><br></pre></td></tr></table></figure><p>计算出直方图后要对结果数组进行进行归一化，然后循环画出直方图。</p><h3 id="直方图对比">直方图对比</h3><p><kbd>compareHist()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double compareHist( InputArray H1, InputArray H2, int method );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入直方图1</p><p>第二个参数是输入直方图2</p><p>第三个参数是对比模式</p><blockquote><p>对比模式有：</p><p>相关性比较：CV_COMP_CORREL概率论中的相关系数，绝对值为1时两图相同，为0时完全不相关</p><p>卡方比较： CV_COMP_CHISQR返回值为0时两图相同，为1时两图无关</p><p>十字比较：CV_COMP_INTERSECT取每个位置两者的最小值累加，不是很好用</p><p>巴氏距离：CV_COMP_BHATTACHARYYA两图相同时为1，不相关时为0，相对而言效果最好</p></blockquote></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double compare_12 &#x3D; compareHist(hist_1 , hist_2 , CV_COMP_BHATTACHARYYA);</span><br></pre></td></tr></table></figure><p>直方图对图像灰度比较敏感，要做比较时，最好先将图像转到HVS空间再进行直方图计算，最后进行比较。HSV图像计算直方图时，需要计算的通道为第一和第二通道。</p><h3 id="直方图均衡化">直方图均衡化</h3><p><kbd>equalizeHist()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void equalizeHist( InputArray src, OutputArray dst );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入图像，需要是单通道</p><p>第二个参数是输出图像</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">equalizeHist(image_in , image_out);</span><br></pre></td></tr></table></figure><p>直方图均衡化可以提高不同光照下的图像效果，使画面呈现出更多细节，增强后续处理的效果。</p><h3 id="直方图反向映射">直方图反向映射</h3><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calcBackProject( const Mat* images, int nimages,const int* channels, const SparseMat&amp; hist, OutputArray backProject, const float** ranges,double scale &#x3D; 1, bool uniform &#x3D; true );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是图像的地址</p><p>第二个参数是图像个数</p><p>第三个参数是通道的角标数组</p><p>第四个参数是直方图</p><p>第五个参数是输出图像</p><p>第六个参数是计算范围，与直方图计算里的那个一样</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hist_size &#x3D; 180;&#x2F;&#x2F;直方图个数</span><br><span class="line">float range[] &#x3D; &#123; 0 , 180 &#125;;&#x2F;&#x2F;统计范围，这里使用的是HSV图像，所以是0-180</span><br><span class="line">const float* ranges[] &#x3D; &#123; range &#125;;</span><br><span class="line">int channels[2] &#x3D; &#123; 0,1 &#125;;&#x2F;&#x2F;统计HSV图像的前两个通道</span><br><span class="line">calcHist(&amp;image_hsv, 1, channels, Mat(), image_hist, 1 , &amp;hist_size, ranges);&#x2F;&#x2F;计算出直方图</span><br><span class="line">calcBackProject(&amp;image_hsv, 1, channels, image_hist, hist_back, ranges);直方图反向映射</span><br></pre></td></tr></table></figure><h3 id="直方图匹配">直方图匹配</h3><p><kbd>matchTemplate()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void matchTemplate( InputArray image, InputArray templ,OutputArray result, int method, InputArray mask &#x3D; noArray() );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是待检测图像</p><p>第二个参数是用来检测的图像</p><p>第三个参数是输出图像</p><p>第四个参数是匹配模式</p><blockquote><p>匹配模式有：<br>平方差匹配法：TM_SQDIFF</p><p>归一化平方差匹配法：TM_SQDIFF_NORMED//这两个最佳匹配结果在0处</p><p>相关匹配法：TM_CCORR</p><p>归一化相关匹配法：TM_CCORR_NORMED//这两个最佳匹配结果在最大处</p><p>系数匹配法：TM_CCOEFF</p><p>归一化相关系数匹配法：TM_CCOEFF_NORMED//这两个最佳匹配结果在1，最差在-1，0为不相关</p><p>通常会使用归一化的匹配模式</p></blockquote></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matchTemplate(image_src, temp, temp_out, TM_CCOEFF_NORMED);&#x2F;&#x2F;在image_src上寻找与temp图像匹配的部分，并把计算结果输出到temp_out中</span><br><span class="line">normalize(temp_out,temp_out, -1, 1, NORM_MINMAX); &#x2F;&#x2F;对输出的匹配结果进行归一化</span><br><span class="line">double MinVal &#x3D; 0, MaxVal &#x3D; 0;&#x2F;&#x2F;用于存储匹配结果中的最大最小值</span><br><span class="line">Point MinLoc(0, 0), MaxLoc(0, 0);&#x2F;&#x2F;用于存储匹配结果中最大值与最小值的坐标</span><br><span class="line">minMaxLoc(temp_out, &amp;MinVal, &amp;MaxVal, &amp;MinLoc, &amp;MaxLoc);&#x2F;&#x2F;寻找最值坐标</span><br><span class="line">circle(image_src, Point(MaxLoc.x + temp.cols &#x2F; 2, MaxLoc.y + temp.rows &#x2F; 2), 30, Scalar(0, 0, 255), 2, 8);&#x2F;&#x2F;在原图上的最佳匹配点处画上圆，要注意如果是用平方差匹配要在最小值处画。</span><br></pre></td></tr></table></figure><h2 id="轮廓">轮廓</h2><h3 id="轮廓发现">轮廓发现</h3><p><kbd>findContours()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void findContours( InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode,int method, Point offset &#x3D; Point());</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的图像，需要是完成Canny边缘检查的图像</p><p>第二个参数是输出的轮廓，包含多个轮廓，每个轮廓又包含很多的点，所以一般用vector&lt;vector(Point)&gt;类型的数据进行储存</p><p>第三个参数是拓扑信息，里边存储了每个轮廓与其他轮廓的拓扑关系，后一个轮廓 前一个轮廓 父轮廓 内嵌轮廓，一共四个相关轮廓的索引编号，所以一般用vector&lt;Vec4i&gt;进行储存，拓扑信息与每个轮廓一一对应</p><p>第四个参数是轮廓检索模式</p><blockquote><p>轮廓检索模式有：</p><p>只检测最外围轮廓： CV_RETR_EXTERNAL内部轮廓被忽略</p><p>检测所有的轮廓： CV_RETR_LIST   检测所有轮廓但检测到的轮廓不建立等级关系，相互独立。所以不存在父轮廓和内嵌轮廓。拓扑信息的第三、四位默认为-1</p><p>检测所有的轮廓且建立两个等级关系：CV_RETR_CCOMP  不同轮廓间外围为顶层，如果内围轮廓内部也包括其他轮廓，则它也被视作顶层。</p><p>检测所有的轮廓且建立等级树： CV_RETR_TREE  会根据轮廓的关系建立等级树，外围包括内围，内围也可包括其他轮廓。</p></blockquote><p>第五个参数是轮廓的呈现方法</p><blockquote><p>呈现方法有：</p><p>获取每个轮廓的每个像素：CV_CHAIN_APPROX_NONE  将相互之间距离不超过1的点全部相连</p><p>只取轮廓的拐点像素：CV_CHAIN_APPROX_SIMPLE 对信息进行了压缩</p><p>teh-Chinl chain 近似算法：CV_CHAIN_APPROX_TC89_L1</p><p>CV_CHAIN_APPROX_TC89_KCOS</p></blockquote></blockquote><h3 id="轮廓绘制">轮廓绘制</h3><p><kbd>drawContours()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void drawContours( InputOutputArray image, InputArrayOfArrays contours,int contourIdx, const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, InputArray hierarchy &#x3D; noArray(), int maxLevel &#x3D; INT_MAX, Point offset &#x3D; Point() );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是绘制的图像</p><p>第二个参数是输入的轮廓信息</p><p>第三个参数是轮廓的索引号</p><p>第七个参数是拓扑信息</p><p>第八个参数是最大层数，0代表只绘制当前 ，1代表绘制当前以及内嵌</p><p>第九个参数是每个点的偏移量，一般不设置</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvtColor(image_src, image_gray, CV_BGR2GRAY);</span><br><span class="line">Canny(image_gray, image_canny, 40, 140);</span><br><span class="line">Mat image_out(image_canny.size(),CV_8UC3);</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">findContours(image_canny, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);</span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">drawContours(image_out,contours,i,Scalar(255,0,0),1,LINE_AA,hierarchy);</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure><h3 id="凸包">凸包</h3><p><kbd>convexHull()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void convexHull( InputArray points, OutputArray hull, bool clockwise &#x3D; false, bool returnPoints &#x3D; true );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的轮廓数据</p><p>第二个参数是输出的凸包数据，数据类型与轮廓数据一样 vector&lt;vector&lt;Point&gt;&gt;</p><p>第三个参数是检测的方向，默认为逆时针</p><p>第四个参数是操作标识符，一般不用设置</p></blockquote><p>样例代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours ;&#x2F;&#x2F;用于存储轮廓数据</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;&#x2F;&#x2F;用于存储轮廓的拓扑信息</span><br><span class="line">findContours(image_canny, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_TC89_KCOS);&#x2F;&#x2F;发现轮廓</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt;convex(contours.size());&#x2F;&#x2F;用于存储凸包信息</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; contours.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">convexHull(contours[i], convex[i]);&#x2F;&#x2F;检测凸包</span><br><span class="line">&#125;</span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">drawContours(image_out,convex,i,Scalar(0,0,0),2 , LINE_AA );&#x2F;&#x2F;绘制凸包</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure><h3 id="绘制矩形-椭圆框">绘制矩形/椭圆框</h3><h4 id="压缩点集">压缩点集</h4><p><kbd>approxPolyDP()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void approxPolyDP( InputArray curve, OutputArray approxCurve,double epsilon, bool closed );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入点集，一般是轮廓数据</p><p>第二个参数是压缩后的点集</p><p>第三个参数是压缩精度，代表压缩后曲线与原曲线的最大距离</p><p>第四个参数是是否闭合，true是闭合</p></blockquote><h4 id="获得矩形">获得矩形</h4><h5 id="无角度">无角度</h5><p><kbd>boundingRect()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rect boundingRect( InputArray points );</span><br></pre></td></tr></table></figure><blockquote><p>参数为点集</p></blockquote><p>返回值为Rect，所以一般用vector&lt;Rect&gt;进行储存</p><h5 id="倾斜">倾斜</h5><p><kbd>minAreaRect()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RotatedRect minAreaRect( InputArray points );</span><br></pre></td></tr></table></figure><blockquote><p>参数为点集</p></blockquote><p>返回值为RotateRect，包含矩形的四个顶点。一般用vector&lt;RotateRect&gt;进行储存。</p><p>需要注意，这个函数对输入点集的个数有要求，至少要有四个点以上。</p><h4 id="获得圆">获得圆</h4><h5 id="圆形-2">圆形</h5><p><kbd>minEnclosingCircle()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void minEnclosingCircle( InputArray points, CV_OUT Point2f&amp; center, CV_OUT float&amp; radius );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入点集</p><p>第二个参数是圆心集合</p><p>第三个参数是半径集合</p></blockquote><h5 id="椭圆-2">椭圆</h5><p><kbd>fitEllipse()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RotatedRect fitEllipse( InputArray points );</span><br></pre></td></tr></table></figure><blockquote><p>参数是输入点集</p></blockquote><p>返回值与旋转矩形一致，需要注意这个函数的输入点集至少要有六个点，使用时需要进行判断。</p><h4 id="样例代码">样例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;拟合</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; approx(contours.size());&#x2F;&#x2F;存储压缩后的点集</span><br><span class="line">vector&lt;Rect&gt; rect(contours.size());&#x2F;&#x2F;存储拟合的无角度矩形</span><br><span class="line">vector&lt;RotatedRect&gt;rotate(contours.size());&#x2F;&#x2F;存储拟合的有角度矩形</span><br><span class="line">vector&lt;RotatedRect&gt;  elipse_(contours.size());&#x2F;&#x2F;存储拟合的椭圆</span><br><span class="line">vector&lt;Point2f&gt; css(contours.size());&#x2F;&#x2F;存储拟合圆的圆心</span><br><span class="line">vector&lt;float&gt; rad(contours.size());&#x2F;&#x2F;存储拟合圆的半径</span><br><span class="line">for(int i&#x3D;0 ; i&lt;contours.size() ; i++)&#x2F;&#x2F;遍历每一个轮廓点集</span><br><span class="line">&#123;</span><br><span class="line">approxPolyDP(contours[i], approx[i], 3 , true);&#x2F;&#x2F;压缩点集</span><br><span class="line">rect[i] &#x3D; boundingRect(approx[i]);&#x2F;&#x2F;拟合无角度矩形</span><br><span class="line">rotate[i] &#x3D; minAreaRect(approx[i]);&#x2F;&#x2F;拟合有角度矩形</span><br><span class="line">minEnclosingCircle(approx[i], css[i], rad[i]);&#x2F;&#x2F;拟合圆</span><br><span class="line">if (approx[i].size() &gt; 5) &#123;&#x2F;&#x2F;确保点集中至少六个点</span><br><span class="line">elipse_[i] &#x3D; fitEllipse(approx[i]);&#x2F;&#x2F;拟合椭圆</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制</span><br><span class="line"></span><br><span class="line">Point2f rotate_point[4];&#x2F;&#x2F;用于取用拟合有角度矩形的四个顶点数据</span><br><span class="line">for (int i &#x3D; 0; i &lt; approx.size(); i++)&#x2F;&#x2F;遍历每个轮廓进行绘制</span><br><span class="line">&#123;</span><br><span class="line">rotate[i].points(rotate_point);&#x2F;&#x2F;将顶点数据存入rotate_point</span><br><span class="line">rectangle(image_src, rect[i], Scalar(0, 0, 0), 3, LINE_AA);&#x2F;&#x2F;绘制无角度矩形</span><br><span class="line">circle(image_src, css[i], rad[i], Scalar(100, 0, 100));&#x2F;&#x2F;绘制圆</span><br><span class="line">ellipse(image_src, elipse_[i], Scalar(0, 100, 100));&#x2F;&#x2F;绘制椭圆</span><br><span class="line">for (int k &#x3D; 0; k &lt; 4; k++)</span><br><span class="line">&#123;</span><br><span class="line">line(image_src, rotate_point[k], rotate_point[(k+1)%4],Scalar(0,0,255));&#x2F;&#x2F;使用四个顶点数据绘制旋转矩形，(k+1)%4是为了使矩形闭合且不超出边界</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像矩以及轮廓面积-长度计算">图像矩以及轮廓面积/长度计算</h3><h4 id="图像矩">图像矩</h4><p><kbd>moments()</kbd>函数与类</p><p>通过轮廓数据计算中心距,可以用来拟合轮廓质心</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Moments moments( InputArray array, bool binaryImage &#x3D; false );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的轮廓数据</p><p>第二个参数是是否进行二值化，如果选true，灰度图中非零点均会被看作1</p></blockquote><p>返回值的数据类型为Moments类，一般用vector&lt;Moments&gt;进行储存。</p><h4 id="轮廓面积">轮廓面积</h4><p><kbd>contourArea()</kbd>函数</p><p>通过轮廓数据计算轮廓面积</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double contourArea( InputArray contour, bool oriented &#x3D; false );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的轮廓数据</p></blockquote><h4 id="轮廓长度">轮廓长度</h4><p><kbd>arcLength()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double arcLength( InputArray curve, bool closed );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入的轮廓数据</p><p>第二个参数是指定轮廓是否闭合</p></blockquote><h4 id="样例代码-2">样例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Moments&gt; moment(contours.size());&#x2F;&#x2F;用于存储图像矩</span><br><span class="line">vector&lt;Point2f&gt; points(contours.size());&#x2F;&#x2F;用于存储拟合的质心</span><br><span class="line"></span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">drawContours(image_out, contours, i, Scalar(0, 0, 0), 2, LINE_AA);&#x2F;&#x2F;绘制轮廓</span><br><span class="line">moment[i] &#x3D; moments(contours[i]);&#x2F;&#x2F;根据轮廓计算图像矩</span><br><span class="line">contourArea(contours[i]);&#x2F;&#x2F;根据轮廓计算面积</span><br><span class="line">&#x2F;&#x2F;拟合质心，质心的x为图像矩的m10&#x2F;m00,y为图像矩的m01&#x2F;m00,static_cast是为了保证数据类型为float</span><br><span class="line">points[i] &#x3D; Point(static_cast&lt;float&gt;(moment[i].m10 &#x2F; moment[i].m00), static_cast&lt;float&gt;(moment[i].m01 &#x2F; moment[i].m00));</span><br><span class="line">circle(image_out, points[i], 2, Scalar(255, 255, 0), 2);&#x2F;&#x2F;绘制质心</span><br><span class="line">cout &lt;&lt; &quot;轮廓&quot; &lt;&lt; i &lt;&lt; &quot;的面积为&quot; &lt;&lt; contourArea(contours[i]) &lt;&lt; endl &lt;&lt; &quot;长度为&quot; &lt;&lt; arcLength(contours[i],true)&lt;&lt;endl;&#x2F;&#x2F;输出面积以及轮廓长度</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure><h3 id="点多边形检测">点多边形检测</h3><p>用于检测点与封闭轮廓的位置关系</p><p><kbd>pointPolygonTest()</kbd>函数</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数是输入轮廓数据</p><p>第二个参数是检测点</p><p>第三个参数是设定是否要返回距离，如果是true则返回值为该点到轮廓的距离（外部为正，内部为负），如果为false，则返回值1、0、-1分别代表轮廓外，轮廓上、轮廓内</p></blockquote><h3 id="分水岭算法">分水岭算法</h3><p>用于分离图像上的不同部分</p><blockquote><p>这部分的代码 我一直编译失败，查了半天资料也没找出来问题，就先放下了，之后具体用到的时候再补上。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;这篇博客只用来记录目前我已经接触过的API，只涉及用法及效果，不涉及背后算法，具体算法我会在其他的博客中进行介绍。随着逐渐学习，我也会对这篇博客进行动态更新，有些内容缺少的就是我也还没弄懂的。&lt;/p&gt;
&lt;p&gt;并不会详细解释API，更适
      
    
    </summary>
    
    
    
      <category term="动态更新" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
      <category term="图像处理基础" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
      <category term="API汇总" scheme="http://yoursite.com/tags/API%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>图像处理基础学习笔记（二）——图像操作（Mat对象、读入、初始化、输出、点操作）</title>
    <link href="http://yoursite.com/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C/</id>
    <published>2020-07-09T11:59:50.000Z</published>
    <updated>2020-07-26T12:29:24.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="像素点">像素点</h2><p>图像的像素可以用多个数据进行表示，如单通道的图像可以用一个8位二进制数对像素点进行描述，当然也可以用16位、32位。</p><p>但对于多个通道的图像，如RGB这种三通道，需要三个数据对单点进行描述。就难以使用C++或者C里的数据类型了，OpenCV中提供了一个模板类Vec(向量)。</p><blockquote><p>&lt;Vec 通道数 数据类型&gt;<br>通道数代表有几个数据<br>数据类型代表是由哪种数据类型组成的矩阵<br>b-uchar   s-short   i-int   f-float    d-double<br><Vec1b> //代表一个uchar类型数据组成的矩阵，可以用于灰度图<br><Vec3b> //代表三个uchar类型数据组成的矩阵，多用于RGB图<br><Vec4b> //代表四个uchar类型数据组成的矩阵，可用于显示带透明度通道的RGB图像</p></blockquote><p>以这种数据类型就可以对色彩进行描述，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">Vec3b color;&#x2F;&#x2F;定义三通道uchar类型矩阵color</span><br><span class="line">color[0] &#x3D; 0;&#x2F;&#x2F;依次为矩阵中的三个数据，默认值为0</span><br><span class="line">color[1] &#x3D; 0;</span><br><span class="line">color[2] &#x3D; 255;</span><br><span class="line">cout &lt;&lt; color &lt;&lt; endl;&#x2F;&#x2F;cout可以直接输出矩阵</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wx2.sbimg.cn/2020/07/09/CRCud.png" alt="输出效果"></p><h2 id="图像-初始化-读入、输出">图像 初始化/读入、输出</h2><p>在OpenCV中，保存图像操作使用的是<kbd>Mat</kbd>对象，读入图像使用的是<kbd>imread</kbd>函数。</p><p>这是imread的原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat imread( const String&amp; filename, int flags &#x3D; IMREAD_COLOR );</span><br></pre></td></tr></table></figure><p>其中第一个参数是图片的路径，第二个参数是读取图片时采用的色彩模式。</p><p>预设的色彩模式一共有（没有备注的几个我也不是很清楚）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMREAD_UNCHANGED       &#x2F;&#x2F;按照原图像的色彩模式读入     </span><br><span class="line">IMREAD_GRAYSCALE       &#x2F;&#x2F;单通道灰度图     </span><br><span class="line">IMREAD_COLOR           &#x2F;&#x2F;BGR色彩模式（三个通道顺序并不是RGB）     </span><br><span class="line">IMREAD_ANYDEPTH        &#x2F;&#x2F;根据深度确定读入的通道数     </span><br><span class="line">IMREAD_ANYCOLOR             </span><br><span class="line">IMREAD_LOAD_GDAL            </span><br><span class="line">IMREAD_REDUCED_GRAYSCALE_2  &#x2F;&#x2F;图像尺寸变为一半的单通道灰度图</span><br><span class="line">IMREAD_REDUCED_COLOR_2      &#x2F;&#x2F;图像尺寸变为一半的BGR彩色图</span><br><span class="line">IMREAD_REDUCED_GRAYSCALE_4  &#x2F;&#x2F;类比上边，是图像尺寸变为四分之一的单通道灰度图</span><br><span class="line">IMREAD_REDUCED_COLOR_4      </span><br><span class="line">IMREAD_REDUCED_GRAYSCALE_8  </span><br><span class="line">IMREAD_REDUCED_COLOR_8      </span><br><span class="line">IMREAD_IGNORE_ORIENTATION</span><br></pre></td></tr></table></figure><p>输出图像使用的是<kbd>imshow</kbd>函数，这是它的函数原型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void imshow(const String&amp; winname, InputArray mat);</span><br></pre></td></tr></table></figure><p>第一个参数是窗口名，第二个参数是需要输出的Mat对象。</p><p>关于窗口，有一个用于创建窗口的<kbd>namedwindow</kbd>函数，这是它的原型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE);</span><br></pre></td></tr></table></figure><p>第一个参数是创建窗口的窗口名，第二个参数是用于调整窗口的尺寸模式。</p><p>预设的尺寸模式有（没有备注的就是我也不清楚的）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WINDOW_NORMAL    &#x2F;&#x2F;窗口可以随意调整大小，窗口内的图片也会一起变化大小</span><br><span class="line">WINDOW_AUTOSIZE   &#x2F;&#x2F;窗口的尺寸只能全屏或者刚好等于图片尺寸，且图片尺寸固定</span><br><span class="line">WINDOW_OPENGL    </span><br><span class="line">WINDOW_FULLSCREEN </span><br><span class="line">WINDOW_FREERATIO  </span><br><span class="line">WINDOW_KEEPRATIO  </span><br><span class="line">WINDOW_GUI_EXPANDED</span><br><span class="line">WINDOW_GUI_NORMAL</span><br></pre></td></tr></table></figure><p>如果不使用<kbd>namedwindow</kbd>创建的窗口，那么<kbd>imshow</kbd>会自行创建一个窗口名为第一个参数，且尺寸模式为<kbd>WINDOW_AUTOSIZE</kbd>的窗口，并且将图片呈现在上边。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">Mat demo;</span><br><span class="line">demo &#x3D; imread(&quot;F:&#x2F;&#x2F;opencv file&#x2F;眼睛猫.jpg&quot;, IMREAD_UNCHANGED);&#x2F;&#x2F;以原色彩模式读入图片</span><br><span class="line">&#x2F;&#x2F;namedWindow(&quot;demo&quot;, WINDOW_NORMAL);可以用也可以不用，但如果窗口的大小需要调整就必须得用该函数创建了</span><br><span class="line">imshow(&quot;demo&quot;, demo);&#x2F;&#x2F;在demo窗口中输出demo</span><br><span class="line">waitKey(0);&#x2F;&#x2F;让窗口保持</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wx1.sbimg.cn/2020/07/10/CcMkj.png" alt="呈现效果"></p><p>Mat对象初始化除了可以直接读取图片，还可以自行初始化。</p><p>可以使用<kbd>Mat::zeros</kbd>函数。该函数一共有三个重载。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zeros(Size size, int type);</span><br><span class="line">zeros(int rows, int cols, int type);</span><br><span class="line">zeros(int ndims, const int* sz, int type);</span><br></pre></td></tr></table></figure><p>我只用过前两个，第一个重载中的第一个参数是初始化图片的大小，可以用<kbd>Size</kbd>生成，<kbd>Size</kbd>有两个参数，分别是行数和列数，第二个参数是设置图片的颜色矩阵模式。常用的有<kbd>CV_8UC3</kbd><kbd>CV_8UC1</kbd>等，8代表每个通道的数据是八位，UC代表数据类型为uchar，3和1代表的是色彩通道数，这两个矩阵模式多用来表示RGB图像与灰度图像。</p><p>第二个重载跟第一个差不多，只是把<kbd>Size</kbd>拆开了而已。</p><p>用这种方式初始化，所有的通道数值都为0。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">Mat demo;</span><br><span class="line">demo &#x3D; Mat::zeros(Size(300, 300), CV_8UC3);&#x2F;&#x2F;以三通道模式初始化一个尺寸为300*300的图像</span><br><span class="line">imshow(&quot;demo&quot;, demo);&#x2F;&#x2F;直接输出图片，</span><br><span class="line">waitKey(0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wx2.sbimg.cn/2020/07/10/CcCTR.png" alt="初始化"></p><p>除了<kbd>Mat::zeros</kbd>外还可以使用<kbd>creat</kbd>,两个函数的参数类似，而<kbd>creat</kbd>是<kbd>Mat</kbd>对象的成员函数，可以直接使用<kbd>demo.creat()</kbd>进行初始化，比较大的区别是，<kbd>creat</kbd>初始的通道数值均为最大值。</p><p>除了上述初始化方法外，还可以从别的对象那里复制。</p><p>可以直接用 <kbd>=</kbd>把一个对象赋给另一个，也可以用<kbd>copyTo</kbd>函数，不同的是<kbd>copyTo</kbd>可以通过添加掩膜参数使得只复制指定区域，这个后边会说。</p><h2 id="at指针">at指针</h2><blockquote><p>尚未完结</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;像素点&quot;&gt;像素点&lt;/h2&gt;
&lt;p&gt;图像的像素可以用多个数据进行表示，如单通道的图像可以用一个8位二进制数对像素点进行描述，当然也可以用16位、32位。&lt;/p&gt;
&lt;p&gt;但对于多个通道的图像，如RGB这种三通道，需要三个数据对单点进行描述。就难以使用C++或者C里的数
      
    
    </summary>
    
    
    
      <category term="图像处理基础" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>图像处理基础学习笔记（一）——图像处理简介</title>
    <link href="http://yoursite.com/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B/</id>
    <published>2020-07-09T00:53:45.000Z</published>
    <updated>2020-07-09T03:05:44.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像">图像</h2><p>现代电脑中常见的各种图片比如.jpg .png本质上是各种像素的集合，图片的分辨率就指的是它横向与纵向分别是多少个像素。这一点在像素图片中很明显能看出来。</p><p><img src= "/img/loading.gif" data-src="https://wx2.sbimg.cn/2020/07/09/CGXbw.jpg" alt="像素s" style="zoom:50%;" /></p><p>每个像素只有单一的颜色，整个图片就是由<kbd>横向像素</kbd>*<kbd>纵向像素</kbd>=<kbd>分辨率</kbd>个像素组成的。那么对图像进行处理的思路就很清晰了，对每个点上的像素值进行修改，就可以实现图像的变化。</p><h2 id="像素">像素</h2><h3 id="色彩">色彩</h3><p>已知图像是由像素点组成的，那么像素点具体是什么。</p><p>首先我们需要明白人眼识别颜色的原理，当光线照射到物体表面，一部分波长的光被物体吸收，而剩下波长的光线会被反射进入人眼，人眼视网膜上的感光细胞会对特定范围波长的光线有感知效果。这个范围就是可见光的波长范围，而研究表明，人眼中负责感光的视锥细胞有三种，分别对红、绿、蓝三种光线敏感，也就是说，人眼感知色彩是通过对红绿蓝三种颜色的光线进行混合。</p><p>后来科学家通过研究，证明通过红绿蓝三种颜色不同值的混合，可以制出可见光中任何一种颜色。自然而然的，彩色显示器就选择了以红绿蓝三种原色为基础调配出彩色的方式。这种显色方式被称为<kbd>RGB</kbd>，由RGB三个数值组成的三维空间就是RGB的色彩空间，这个立方体中的任意一个点都是一个特定的颜色，这种以三个数值描述像素点色彩的图片称为三通道，R、G、B分别是其中一个颜色通道。如果每个通道的取值范围是0-100，那么整个色彩空间里就有一百万种颜色（各通道数值只取正整数）。取值范围越大，可显示的色彩数就越多。</p><img src= "/img/loading.gif" data-src="https://wx2.sbimg.cn/2020/07/09/CGgc6.jpg" alt="R" style="zoom:40%;" /><p>计算机中的数据以二进制的方式储存，每个通道的数值都需要用二进制来记录。目前最常用的是以8位二进制也就是2位十六进制来表示单通道，范围是0-255。而三个通道加起来，就是24位二进制、6位十六进制，这就是24位真彩色，总共可以呈现一千六百多万种颜色，几乎达到人眼极限（32位真彩色是在24位的三通道基础上，加了一个灰度通道，可以理解为给之前单一的颜色加了一个可调透明度的设定，以此来更真实的模拟自然色彩）。</p><p>为了简洁，一个色彩就可以用6位十六进制的数进行描述。有很多在线调色的网页，可以试着玩一玩。</p><p><img src= "/img/loading.gif" data-src="https://wx1.sbimg.cn/2020/07/09/CGjtN.png" alt="RGB调色"></p><h3 id="像素矩阵">像素矩阵</h3><p>经过上边的说明，应该已经清楚每种色彩可以用2位十六进制进行描述，那么整个图片就是n个像素的拼接。也就是说每个像素点包括三个数值，通过修改各个数值就可以实现对像素的操作，那么对每个像素点都通过某种算法进行修改，就可以实现各种各样的图像处理。比如PS中的锐化、模糊、提高对比度等等功能，本质上都是对图像像素点数值的修改。</p><p>比如现在有四个像素点，各通道数值如下表</p><table><thead><tr><th style="text-align:center">R</th><th style="text-align:center">G</th><th style="text-align:center">B</th><th style="text-align:center">R</th><th style="text-align:center">G</th><th style="text-align:center">B</th></tr></thead><tbody><tr><td style="text-align:center">255</td><td style="text-align:center">255</td><td style="text-align:center">255</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">255</td><td style="text-align:center">255</td><td style="text-align:center">255</td></tr></tbody></table><p>还可以表示为</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th></tr></thead><tbody><tr><td style="text-align:center">#FFFFFF</td><td style="text-align:center">#000000</td></tr><tr><td style="text-align:center">#000000</td><td style="text-align:center">#FFFFFF</td></tr></tbody></table><p>呈现效果就如下所示。</p><img src= "/img/loading.gif" data-src="https://wx1.sbimg.cn/2020/07/09/CGzXM.png" alt="呈现s图片" style="zoom:40%;" /><h2 id="具体操作">具体操作</h2><p>上边已经对图像处理的基础原理进行了说明，而在用程序进行具体实现时，我们需要用到一些相关的库。我目前正在学习的是OpenCV，它支持很多种语言，C C++ Python 等都可以支持。我目前只对C和C++有一定的了解，所以后续也是基于C++对OpenCV进行学习。</p><p>这里需要指出，OpenCV是一个封装了很多API的库，但是学习图像处理真正要学习的是它的图像处理算法，了解它是通过什么样的操作、实现了什么样的效果，而不仅仅是学习如何调用API。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像&quot;&gt;图像&lt;/h2&gt;
&lt;p&gt;现代电脑中常见的各种图片比如.jpg .png本质上是各种像素的集合，图片的分辨率就指的是它横向与纵向分别是多少个像素。这一点在像素图片中很明显能看出来。&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; dat
      
    
    </summary>
    
    
    
      <category term="图像处理基础" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>科创项目-视觉追踪系统</title>
    <link href="http://yoursite.com/2020/06/30/%E7%A7%91%E5%88%9B%E9%A1%B9%E7%9B%AE-%E8%A7%86%E8%A7%89%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/06/30/%E7%A7%91%E5%88%9B%E9%A1%B9%E7%9B%AE-%E8%A7%86%E8%A7%89%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-06-30T03:57:54.000Z</published>
    <updated>2020-07-26T12:41:51.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目简介">项目简介</h2><p>​四月底开始接触这个项目，主要的目的是制作出一套能够实时采集<strong>瞳孔数据</strong>，通过<strong>数据分析</strong>得到注视点，最终呈现出来。</p><pre class="mermaid">graph LRA(摄像头采集双眼图像)-->B(图像预处理)B-->C(计算视线)C-->D(在环境图像中标注注视点)D-->A</pre><p>​整个项目在明年年中结项，最后的成果呈现预计要有一套完整硬件设备、配套算法以及各种测试数据。</p><p>​就我个人而言我对图像处理与数据分析部分更感兴趣，所以可能会主要做这方面的工作（项团内部至今还没有人员分工 😅）。</p><hr><h2 id="项目任务安排">项目任务安排</h2><p>​受疫情影响，一直不能回校。再加上五六月连着两个月考试，项团小组至今都没有独立讨论过项目进度安排。个人认为这并不是一个好开端，由于不了解其他人对整个项目的参与热情，也不便发起讨论。</p><p>​但总的来说，在返校前各自就项目所需进行知识学习肯定是首要的。返校后应该会尽快开展项目细节的讨论，确定项目的具体方案。</p><hr><h2 id="项目涉及技术">项目涉及技术</h2><h3 id="硬件">硬件</h3><p>​这部分主要包括电路中的控制部分与视觉采集部分，以及框架的建模。</p><p>​电路部分具体用什么控制，以及用什么方式与视觉采集部分相连还没有确定，但我目前是打算先用树莓派尝试编写算法（吃灰已久🌚）。因为要小型化，所以估计未来要上其他的单片机（到处都是知识盲区😂）。如果开学前我能把算法方面的东西学的差不多，可能也会试着学一下AD。</p><p>​框架的话，组里的两个学长好像比较擅长建模，估计会在其他部分设计完成后，由他们进行框架建模。</p><p>​但就技术难度而言，硬件这部分并不大，主要是<strong>明暗双目图像采集</strong>，以及<strong>环境图像采集</strong>，一共是三个摄像头。最主要的就是要实现三个摄像头的正常工作以及位置标定。</p><pre class="mermaid">graph LRA(硬件)-->B(电路/AD等)A-->C(框架/soildworks等)B-->D(采集图像信息)C-->E(方便携带以及标定位置)</pre><h3 id="软件">软件</h3><p>​这部分可以拓展的就比较多了。</p><p>​最基础的视觉追踪，需要能对明暗双目图像进行处理，得到瞳孔信息，通过数据处理得到视线方程。主要目标就是稳定、准确、快速。</p><pre class="mermaid">graph LRA(采集到的信息)---B(明暗双瞳图片)A---C(环境图片)B-->|数据分析/OpenCV| D(视线方程)D-->|标记注视点|C</pre><p>​目前而言我主要在学习图片的数据分析那部分，主要内容是图像处理的基础理论，以及OpenCV的各种API。</p><p>​如果可以完成上述的基础功能，应该还可以拓展出延申的应用。比如对注视点处的物体进行识别，并加以分析，呈现出相关信息，比如与测温模块结合，或许可以动态呈现注视点的温度信息。不过目前这还只是我的个人想法，如果基础的视觉追踪系统完成的比较早，或许可以考虑一下拓展的应用。</p><h2 id="进度">进度</h2><h3 id="团队状态">团队状态</h3><blockquote><p>四月底项团立项</p><p>五月初初次研讨，说明项团任务</p><p>受期末考试影响，至今还未再次研讨，处于各自学习的状态。</p></blockquote><h3 id="个人状态">个人状态</h3><blockquote><p>五月粗浅的学习了C++基础</p><p>六月开始学习图像处理理论基础，以及OpenCV的基础API</p><p>七月预计会完成OpenCV的基础课程，开始尝试针对项目需求进行程序编写(买成品红外摄像头好贵啊😭)</p></blockquote><h2 id="说明">说明</h2><p>我会动态更新这篇项目介绍博客，以及近期相关学习心得总结😄。</p><p>近期项目相关学习内容：<u><a href="%5Bhttps://colorcats.github.io/tags/%E7%A7%91%E5%88%9B%E9%A1%B9%E7%9B%AE/%5D(https://colorcats.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/)">图像处理基础</a></u></p><h2 id="周记">周记</h2><ul><li>7.5-本周一直在复习期末考试的课程，还得准备科一，没什么时间来做项目。下周考试结束后会再次开始相关工作。</li><li>7.12-本周三考完试后继续学习图像处理，每天写博客的时间不算多，所以更新比较慢。除此以外，由于图像处理的学习快结束了，准备跟同学再开新坑，等确定后再发相关博客吧。</li><li>7.19-本周OpenCV的学习基本结束，正在整理所有学过的API，工作量出乎意料的大，关于原理的博客就暂时停更了，关于上周提到的新坑，由于跟我的长期规划重合度不太高，所以就不专门记述了。</li><li>7.26-本周开始要每天去驾校，同时也开始每天复习考研公共课了，留给我学习其他东西的时间就比较少了，但肯定不会停止。由于暂时没有合适的硬件对项目需求进行针对性编程（买回来的成品红外摄像头的效果一言难尽🌚），所以图像处理的学习就暂时停止了。之后的学习内容暂定是AD的使用以及基础的硬件开发，正式开始后我会发布相关的博客，之前图像处理的博客也会抽空逐渐补上。（工作量是真的大，但愿我填的完坑😭）</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目简介&quot;&gt;项目简介&lt;/h2&gt;
&lt;p&gt;​		四月底开始接触这个项目，主要的目的是制作出一套能够实时采集&lt;strong&gt;瞳孔数据&lt;/strong&gt;，通过&lt;strong&gt;数据分析&lt;/strong&gt;得到注视点，最终呈现出来。&lt;/p&gt;
&lt;pre class=&quot;mermai
      
    
    </summary>
    
    
    
      <category term="科创项目" scheme="http://yoursite.com/tags/%E7%A7%91%E5%88%9B%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="动态更新" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
</feed>
