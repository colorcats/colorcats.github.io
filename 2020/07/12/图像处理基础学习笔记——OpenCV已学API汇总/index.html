<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>图像处理基础学习笔记——OpenCV常用API汇总 | 瞎捣鼓的废宅</title><meta name="description" content="说明 这篇博客只用来记录目前我已经接触过的API，只涉及用法及效果，不涉及背后算法，具体算法我会在其他的博客中进行介绍。随着逐渐学习，我也会对这篇博客进行动态更新，有些内容缺少的就是我也还没弄懂的。 并不会详细解释API，更适合有一定经验的人查阅。 我也只是个初学者，很多内容都是跟着教程的框架进行学习，如果内容上有错误欢迎大家指正与补充。  基础操作 读入 图片 imread()函数 Mat im"><meta name="keywords" content="动态更新,图像处理基础,API汇总"><meta name="author" content="colorcat,color_cat@126.com"><meta name="copyright" content="colorcat"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://wx1.sbimg.cn/2020/07/03/2UXcn.jpg"><link rel="canonical" href="http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><meta property="og:type" content="article"><meta property="og:title" content="图像处理基础学习笔记——OpenCV常用API汇总"><meta property="og:url" content="http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/"><meta property="og:site_name" content="瞎捣鼓的废宅"><meta property="og:description" content="说明 这篇博客只用来记录目前我已经接触过的API，只涉及用法及效果，不涉及背后算法，具体算法我会在其他的博客中进行介绍。随着逐渐学习，我也会对这篇博客进行动态更新，有些内容缺少的就是我也还没弄懂的。 并不会详细解释API，更适合有一定经验的人查阅。 我也只是个初学者，很多内容都是跟着教程的框架进行学习，如果内容上有错误欢迎大家指正与补充。  基础操作 读入 图片 imread()函数 Mat im"><meta property="og:image" content="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg"><meta property="article:published_time" content="2020-07-12T06:49:52.000Z"><meta property="article:modified_time" content="2020-07-26T12:27:10.365Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="图像处理基础学习笔记（二）——图像操作（Mat对象、读入、初始化、输出、点操作）" href="http://yoursite.com/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="瞎捣鼓的废宅" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://wx1.sbimg.cn/2020/07/03/2UXcn.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-desktop"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/borad"><i class="fa-fw far fa-clipboard"></i><span> 留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础操作"><span class="toc-number">2.</span> <span class="toc-text">基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读入"><span class="toc-number">2.1.</span> <span class="toc-text">读入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图片"><span class="toc-number">2.1.1.</span> <span class="toc-text">图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#视频或摄像头"><span class="toc-number">2.1.2.</span> <span class="toc-text">视频或摄像头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-number">2.2.</span> <span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图片-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#视频"><span class="toc-number">2.2.2.</span> <span class="toc-text">视频</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#颜色"><span class="toc-number">2.3.</span> <span class="toc-text">颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数（随机色彩）"><span class="toc-number">2.4.</span> <span class="toc-text">随机数（随机色彩）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#像素范围处理"><span class="toc-number">2.5.</span> <span class="toc-text">像素范围处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#色彩转换"><span class="toc-number">2.6.</span> <span class="toc-text">色彩转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道分离"><span class="toc-number">2.7.</span> <span class="toc-text">通道分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道合并"><span class="toc-number">2.8.</span> <span class="toc-text">通道合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图像线性混合"><span class="toc-number">2.9.</span> <span class="toc-text">图像线性混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图像线性运算"><span class="toc-number">2.10.</span> <span class="toc-text">图像线性运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归一化"><span class="toc-number">2.11.</span> <span class="toc-text">归一化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#画线与图形"><span class="toc-number">3.</span> <span class="toc-text">画线与图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线"><span class="toc-number">3.1.</span> <span class="toc-text">线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩形"><span class="toc-number">3.2.</span> <span class="toc-text">矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#圆形"><span class="toc-number">3.3.</span> <span class="toc-text">圆形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆"><span class="toc-number">3.4.</span> <span class="toc-text">椭圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多边形或折线"><span class="toc-number">3.5.</span> <span class="toc-text">多边形或折线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文字"><span class="toc-number">3.6.</span> <span class="toc-text">文字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点操作"><span class="toc-number">4.</span> <span class="toc-text">点操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#卷积操作"><span class="toc-number">5.</span> <span class="toc-text">卷积操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积核"><span class="toc-number">5.1.</span> <span class="toc-text">卷积核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积"><span class="toc-number">5.2.</span> <span class="toc-text">卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模糊"><span class="toc-number">5.3.</span> <span class="toc-text">模糊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#均值模糊-均值滤波"><span class="toc-number">5.3.1.</span> <span class="toc-text">均值模糊&#x2F;均值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中值模糊-中值滤波"><span class="toc-number">5.3.2.</span> <span class="toc-text">中值模糊&#x2F;中值滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高斯模糊-高斯滤波"><span class="toc-number">5.3.3.</span> <span class="toc-text">高斯模糊&#x2F;高斯滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#高斯"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">高斯</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双边高斯"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">双边高斯</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形态学操作"><span class="toc-number">6.</span> <span class="toc-text">形态学操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-number">6.1.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算"><span class="toc-number">6.2.</span> <span class="toc-text">运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测直线-字符"><span class="toc-number">6.3.</span> <span class="toc-text">检测直线&#x2F;字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阈值"><span class="toc-number">7.</span> <span class="toc-text">阈值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阈值操作"><span class="toc-number">7.1.</span> <span class="toc-text">阈值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边缘检测"><span class="toc-number">7.2.</span> <span class="toc-text">边缘检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#霍夫变换"><span class="toc-number">8.</span> <span class="toc-text">霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直线"><span class="toc-number">8.1.</span> <span class="toc-text">直线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#圆"><span class="toc-number">8.2.</span> <span class="toc-text">圆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直方图"><span class="toc-number">9.</span> <span class="toc-text">直方图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直方图计算"><span class="toc-number">9.1.</span> <span class="toc-text">直方图计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直方图对比"><span class="toc-number">9.2.</span> <span class="toc-text">直方图对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直方图均衡化"><span class="toc-number">9.3.</span> <span class="toc-text">直方图均衡化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直方图反向映射"><span class="toc-number">9.4.</span> <span class="toc-text">直方图反向映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直方图匹配"><span class="toc-number">9.5.</span> <span class="toc-text">直方图匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#轮廓"><span class="toc-number">10.</span> <span class="toc-text">轮廓</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#轮廓发现"><span class="toc-number">10.1.</span> <span class="toc-text">轮廓发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轮廓绘制"><span class="toc-number">10.2.</span> <span class="toc-text">轮廓绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#凸包"><span class="toc-number">10.3.</span> <span class="toc-text">凸包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制矩形-椭圆框"><span class="toc-number">10.4.</span> <span class="toc-text">绘制矩形&#x2F;椭圆框</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩点集"><span class="toc-number">10.4.1.</span> <span class="toc-text">压缩点集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获得矩形"><span class="toc-number">10.4.2.</span> <span class="toc-text">获得矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#无角度"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">无角度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#倾斜"><span class="toc-number">10.4.2.2.</span> <span class="toc-text">倾斜</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获得圆"><span class="toc-number">10.4.3.</span> <span class="toc-text">获得圆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#圆形-2"><span class="toc-number">10.4.3.1.</span> <span class="toc-text">圆形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#椭圆-2"><span class="toc-number">10.4.3.2.</span> <span class="toc-text">椭圆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例代码"><span class="toc-number">10.4.4.</span> <span class="toc-text">样例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图像矩以及轮廓面积-长度计算"><span class="toc-number">10.5.</span> <span class="toc-text">图像矩以及轮廓面积&#x2F;长度计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图像矩"><span class="toc-number">10.5.1.</span> <span class="toc-text">图像矩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轮廓面积"><span class="toc-number">10.5.2.</span> <span class="toc-text">轮廓面积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轮廓长度"><span class="toc-number">10.5.3.</span> <span class="toc-text">轮廓长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例代码-2"><span class="toc-number">10.5.4.</span> <span class="toc-text">样例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#点多边形检测"><span class="toc-number">10.6.</span> <span class="toc-text">点多边形检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分水岭算法"><span class="toc-number">10.7.</span> <span class="toc-text">分水岭算法</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">瞎捣鼓的废宅</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-desktop"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/borad"><i class="fa-fw far fa-clipboard"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">图像处理基础学习笔记——OpenCV常用API汇总</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-12 14:49:52"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-26 20:27:10"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-26</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">9k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 33 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="说明">说明</h2>
<p>这篇博客只用来记录目前我已经接触过的API，只涉及用法及效果，不涉及背后算法，具体算法我会在其他的博客中进行介绍。随着逐渐学习，我也会对这篇博客进行动态更新，有些内容缺少的就是我也还没弄懂的。</p>
<p>并不会详细解释API，更适合有一定经验的人查阅。</p>
<p>我也只是个初学者，很多内容都是跟着教程的框架进行学习，如果内容上有错误欢迎大家指正与补充。</p>
<hr>
<h2 id="基础操作">基础操作</h2>
<h3 id="读入">读入</h3>
<h4 id="图片">图片</h4>
<p><kbd>imread()</kbd>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat imread( const String&amp; filename, int flags &#x3D; IMREAD_COLOR );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是图片路径</p>
<p>第二个参数是读入色彩模式</p>
<p>常用的模式：</p>
<p>IMREAD_UNCHANGED 按图片原色彩模式读入</p>
<p>IMREAD_GRAYSCALE 按灰度图读入</p>
<p>IMREAD_COLOR 按BGR彩色读入</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat demo;</span><br><span class="line">demo &#x3D; imread(&quot;F:&#x2F;&#x2F;opencv file&#x2F;picture.jpg&quot; , IMREAD_UNCHANGED);</span><br></pre></td></tr></table></figure>
<h4 id="视频或摄像头">视频或摄像头</h4>
<p><kbd>VideoCapture</kbd>类</p>
<p>使用样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VideoCapture cap;</span><br><span class="line">cap.open(0); &#x2F;&#x2F; cap.open(&quot;F:\\opencv file&#x2F;测试视频.mp4&quot;);</span><br><span class="line">&#x2F;&#x2F;以上等价于 VideoCaputure cap(0);</span><br><span class="line">Mat demo;</span><br><span class="line">while(1)&#123;</span><br><span class="line">cap&gt;&gt;demo</span><br><span class="line">imshow(&quot;demo&quot;,demo);</span><br><span class="line">waitKey(30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建一个<kbd>VideoCapture</kbd>通过<kbd>open</kbd>可以打开摄像头或者视频,摄像头的话是使用摄像头的index号，笔记本摄像头默认为0。视频是使用路径。</p>
<p>然后用<kbd>&gt;&gt;</kbd>读入到<kbd>Mat</kbd>中进行处理，循环输出。</p>
<p><kbd>VideoCapture</kbd>还有一些常用的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap.get(CV_CAP_PROP_FRAME_WIDTH) &#x2F;&#x2F;帧宽度</span><br><span class="line">cap.get(CV_CAP_PROP_FRAME_HEIGHT) &#x2F;&#x2F;帧高度</span><br><span class="line">cap.get(CV_CAP_PROP_FPS);  &#x2F;&#x2F;帧率 x frames&#x2F;s</span><br><span class="line">cap.get(CV_CAP_PROP_FRAME_COUNT); &#x2F;&#x2F;总帧数</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<h4 id="图片-2">图片</h4>
<p><kbd>imwrite()</kbd>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imwrite( const String&amp; filename, InputArray img,const std::vector&lt;int&gt;&amp; params &#x3D; std::vector&lt;int&gt;());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输出的文件路径</p>
<p>第二个参数是要输出的图片</p>
</blockquote>
<h4 id="视频">视频</h4>
<p><kbd>VideoWriter</kbd>类</p>
<blockquote>
<p>这部分我还没倒腾明白，之后用到的时候再补齐</p>
</blockquote>
<h3 id="颜色">颜色</h3>
<p><kbd>Scalar</kbd>对象与函数</p>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scalar color &#x3D; Scalar(255,255,255) 	&#x2F;&#x2F;设置色彩为白色</span><br></pre></td></tr></table></figure>
<h3 id="随机数（随机色彩）">随机数（随机色彩）</h3>
<p><kbd>RNG</kbd>类</p>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RNG rng((unsigned)time(NULL));	&#x2F;&#x2F;声明时需要设定一个种子，一般会设置为当前时间，可以保证每次的种子都不同。</span><br><span class="line">int i &#x3D; rng.uniform(0,255)	&#x2F;&#x2F;uniform(a,b),可以生成[a,b)之间的随机数，返回值与输入的范围值相同，也可以用强制转换得到多种数据类型</span><br></pre></td></tr></table></figure>
<h3 id="像素范围处理">像素范围处理</h3>
<p><kbd>saturate_cast()</kbd>函数</p>
<p>用于使数值不超过数据类型允许范围</p>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(400)		&#x2F;&#x2F;返回255</span><br><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(-100)	&#x2F;&#x2F;返回0</span><br><span class="line">uchar r &#x3D; saturate_cast&lt;uchar&gt;(100)		&#x2F;&#x2F;返回100</span><br></pre></td></tr></table></figure>
<h3 id="色彩转换">色彩转换</h3>
<p><kbd>cvtColor()</kbd>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cvtColor( InputArray src, OutputArray dst, int code, int dstCn &#x3D; 0 );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是转换模式</p>
<p>常用的有：</p>
<p>CV_BGR2GRAY	//BGR转灰度</p>
<p>CV_BGR2HSV 	//BGR转HSV</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvtColor(demo,demo,CV_BGR2GRAY);  &#x2F;&#x2F;从BGR彩色图转换为灰度图</span><br></pre></td></tr></table></figure>
<p>形态学操作、直方图、边缘检测等API需要输入单通道的图，就可以将彩色图转换为单通道的灰度图，也可以选择将不同的通道分为不同的图像。</p>
<h3 id="通道分离">通道分离</h3>
<p>将多通道的彩色图像，分为多个单通道的图。</p>
<p><kbd>split()</kbd>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void split(const Mat&amp; src, Mat* mvbegin)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入Mat对象地址</p>
<p>第二个参数是分通道输出的Mat对象数组</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat dst[3];			&#x2F;&#x2F;声明Mat对象数组</span><br><span class="line">split(demo,dst);	&#x2F;&#x2F;将demo对象的三个通道分别赋给dst数组</span><br></pre></td></tr></table></figure>
<p>要注意分离后的图像都是单通道，直接显示都是灰度图。</p>
<h3 id="通道合并">通道合并</h3>
<p>将多个单通道图像合并为一个多通道的图像</p>
<p><kbd>merge()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void merge(InputArrayOfArrays mv, OutputArray dst);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的多个单通道矩阵/图像的阵列，必须有相同深度和尺寸</p>
<p>第二个参数是合并后的矩阵/图像，通道数需要与参数一中的个数一致</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Mat&gt; channels;	&#x2F;&#x2F;用于储存分离后的通道</span><br><span class="line">split(image_src, channels);		&#x2F;&#x2F;分离通道</span><br><span class="line">merge(channels, image_dst);		&#x2F;&#x2F;合并通道</span><br></pre></td></tr></table></figure>
<p>该函数是上边<kbd>split()</kbd>的逆操作，参数也类似。</p>
<h3 id="图像线性混合">图像线性混合</h3>
<p><kbd>addWeighted()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWeighted(InputArray src1, double alpha, InputArray src2,double beta, double gamma, OutputArray dst, int dtype &#x3D; -1);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像1</p>
<p>第二个参数是图像1所占的比例</p>
<p>第三个参数是输入图像2</p>
<p>第四个参数是图像2所占的比例</p>
<p>第五个参数是偏差值，用0就可以</p>
<p>第六个参数是输出图像</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addWeighted(image1, 0.4 , image2 , 0.6 , 0 , image_out);</span><br></pre></td></tr></table></figure>
<h3 id="图像线性运算">图像线性运算</h3>
<p><kbd>cvConvertScale()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvConvertScale( const CvArr* src, CvArr* dst, double scale ,double shift  );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入矩阵</p>
<p>第二个参数是输出矩阵</p>
<p>第三个参数是乘数因子</p>
<p>第四个参数是加权值</p>
<p>最后结果是输入矩阵中的每个元素   乘以乘数加上加权值  得到输出矩阵</p>
</blockquote>
<p><kbd>cvConvertScaleAbs()</kbd>函数</p>
<p>参数与上边的API一致，区别是这个API输出时会取绝对值。</p>
<h3 id="归一化">归一化</h3>
<p><kbd>normalize()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void normalize(InputArray src, InputOutputArray dst, double alpha&#x3D;1, double beta&#x3D;0, int norm_type&#x3D;NORM_L2, int dtype&#x3D;-1, InputArray mask&#x3D;noArray() )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入数组/图像</p>
<p>第二个参数是输出数组/图像</p>
<p>第三个参数是用来规范值或者规范范围，并且是下限。</p>
<p>第四个参数是用来规范范围并且是上限	只对NORM_MINMAX有效</p>
<p>第五个参数是归一化的模式</p>
<blockquote>
<p>归一到（min，max）范围内：NORM_MINMAX	最小值为0，最大值为1，其他数根据比例计算</p>
<p>根据切比雪夫距离归一：NORM_INF	最大值为1，其他数除以最大值</p>
<p>根据曼哈顿距离归一：NORM_L1	每个数除以所有数和（绝对值）</p>
<p>根据欧几里得距离归一：NORM_L2 	每个数除以所有数平方和的开方</p>
</blockquote>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;double&gt;demo &#x3D; &#123;10,17,20&#125;;</span><br><span class="line">normalize(demo,demo, 1 , 255 ,NORM_L1);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="画线与图形">画线与图形</h2>
<h3 id="线">线</h3>
<p><kbd>line()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color,int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的图像</p>
<p>第二个参数是线段起始点</p>
<p>第三个参数是线段结束点</p>
<p>第四个参数是线段颜色</p>
<p>第五个参数是线段宽度</p>
<p>第六个参数是线形</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">line(image , Point(50,50) , Point(100,100) , Scalar(255,0,0) , 3 , LINE_8);</span><br></pre></td></tr></table></figure>
<h3 id="矩形">矩形</h3>
<p><kbd>rectangle()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rectangle(InputOutputArray img, Point pt1, Point pt2,const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与上边划线类似，第一个点是矩形左上角，第二个点是矩形右下角</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rectangle(image , Point(50,50) , Point(100,100) , Scalar(255,0,0) , 3 , LINE_8);</span><br></pre></td></tr></table></figure>
<h3 id="圆形">圆形</h3>
<p><kbd>circle()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void circle(InputOutputArray img, Point center, int radius, const Scalar&amp; color, int thickness &#x3D; 1,int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是圆心坐标</p>
<p>第三个参数是半径</p>
<p>第四个参数是颜色</p>
<p>第五个参数是线宽</p>
<p>第六个参数是线形</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">circle(image, Point(50,50) , 20 , Scalar(255,0,0) , 2 , LINE_8);</span><br></pre></td></tr></table></figure>
<h3 id="椭圆">椭圆</h3>
<p><kbd>ellipse()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ellipse(InputOutputArray img, Point center, Size axes,</span><br><span class="line">double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness &#x3D; 1,int lineType &#x3D; LINE_8, int shift &#x3D; 0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是椭圆中心点</p>
<p>第三个参数是椭圆的大小（姑且可以认为是可以框住椭圆的矩形尺寸，可以以此确定椭圆的长轴与短轴长度）</p>
<p>第四个参数是椭圆沿逆时针方向旋转的角度</p>
<p>第五、六个参数分别是椭圆开始的角度以及结束的角度（用于画带缺口的椭圆线，角度沿长轴顺时针方向）</p>
<p>第七个参数是颜色</p>
<p>第八个参数是线宽</p>
<p>第九个参数是线形</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ellipse(image , Point(100,100) , Size(30,60) , 30 , 0 , 180 , Scalar(255,0,0) , 2 , LINE_8);</span><br></pre></td></tr></table></figure>
<h3 id="多边形或折线">多边形或折线</h3>
<p><kbd>polylines()</kbd>函数</p>
<p>支持一次性画多个多边形</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void polylines(Mat&amp; img, const Point* const* pts, const int* npts,int ncontours, bool isClosed, const Scalar&amp; color,int thickness &#x3D; 1, int lineType &#x3D; LINE_8, int shift &#x3D; 0 );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是画布图像</p>
<p>第二个参数是顶点数组，由于该函数支持同时画多个多边形，所以顶点数组是二维数组，且要将每个数组的头地址再装进一个一维数组中，这里的参数只用最后的一维数组</p>
<p>第三个参数是顶点数量，也是为了画多个图形，所以需要用数组的形式储存顶点数量</p>
<p>第四个参数是多边形的数量</p>
<p>第五个参数是折线是否闭合，真或假</p>
<p>后边的就是颜色、线型之类的了</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Point points[2][3];</span><br><span class="line">points[0][0] &#x3D; Point(50,50);</span><br><span class="line">points[0][1] &#x3D; Point(20,50);</span><br><span class="line">points[0][2] &#x3D; Point(30,40);</span><br><span class="line">points[1][0] &#x3D; Point(60,50);</span><br><span class="line">points[1][1] &#x3D; Point(50,80);</span><br><span class="line">points[1][2] &#x3D; Point(40,30);</span><br><span class="line">const Point* ptr[]&#x3D;&#123;points[0] , points[1]&#125;;</span><br><span class="line">int npts[] &#x3D; &#123;3,3&#125;;</span><br><span class="line">polylines(image , ptr , npts , 2 , ture , Scalar(255,0,0) , 2, LINE_8);</span><br></pre></td></tr></table></figure>
<p><kbd>fillPoly()</kbd>函数</p>
<p>该函数参数与<kbd>polylines</kbd>基本一致，区别是该函数是实心多边形，<kbd>polylines</kbd>只是边框</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fillPoly(Mat&amp; img, const Point** pts,const int* npts, int ncontours,const Scalar&amp; color, int lineType &#x3D; LINE_8, int shift &#x3D; 0, Point offset &#x3D; Point() );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和上边很相似，基本只需要五个参数，输入图像，顶点数组，顶点数量，图形数量，填充颜色</p>
</blockquote>
<h3 id="文字">文字</h3>
<p><kbd>putText()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void putText( InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color,</span><br><span class="line">int thickness &#x3D; 1, int lineType &#x3D; LINE_8,bool bottomLeftOrigin &#x3D; false );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是要输出的字符串</p>
<p>第三个参数是文本框左下角的坐标</p>
<p>第四个参数是字体</p>
<p>第五个参数是尺寸</p>
<p>第六个参数是颜色</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">putText(image , &quot;Hello world&quot; , Point(50,50) , FONT_HERSHEY_COMPLEX , 2 , Scalar(255,0,0));</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="点操作">点操作</h2>
<ol>
<li><kbd>at</kbd>方法</li>
</ol>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uchar value &#x3D; image.at&lt;uchar&gt;(i,j);	&#x2F;&#x2F;获得单通道图像i行j列像素点的值</span><br><span class="line">image.at&lt;uchar&gt;(i,j) &#x3D; 255;	&#x2F;&#x2F;单通道图像赋值操作</span><br><span class="line">uchar value &#x3D; image.at&lt;Vec3b&gt;(i,j)[0];	&#x2F;&#x2F;取出三通道图像i行j列像素点的第一个通道数值。</span><br><span class="line">Vec3b pixel &#x3D; image.at&lt;Vec3b&gt;(i,j);	&#x2F;&#x2F;将三通道图像i行j列像素点数组赋给pixel</span><br></pre></td></tr></table></figure>
<p>需要注意对遍历多通道图像时使用<em>像素点数组</em>进行操作时，列数为<strong>像素点的列数</strong>（及图像列数）。直接获取<em>单通道数值</em>进行操作时，列数为<strong>像素点的列数*通道数</strong>。</p>
<p><kbd>at</kbd>函数可读性高，但效率不高，不适合用来遍历图像。</p>
<ol start="2">
<li><kbd>ptr</kbd>方法</li>
</ol>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uchar* date_in &#x3D; image_in.ptr&lt;uchar&gt;(i);	&#x2F;&#x2F;获取图像第i行像素值的指针,设置为常量是为了保证原图不变，保留副本。</span><br><span class="line">uchar* date_out &#x3D; image_out.ptr&lt;uchar&gt;(i);	</span><br><span class="line">date_out[j] &#x3D; date_in[j];	&#x2F;&#x2F;复制像素</span><br></pre></td></tr></table></figure>
<p>需要特别注意，这里是将一行的数据装进数组，也就意味着对于通道的图，一行数据一共有<strong>图像列数*通道数</strong>个。如果要对单一通道进行操作，遍历时每次应该向下移动<strong>通道数</strong>个数据。</p>
<p>以这种方法遍历，效率更高。</p>
<p><strong>遍历时，单点像素乘以常数可以调整对比度，加减常数可以调整亮度。</strong></p>
<h2 id="卷积操作">卷积操作</h2>
<h3 id="卷积核">卷积核</h3>
<p>想要进行卷积运算需要先定义一个卷积核。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat kernel &#x3D; (Mat_&lt;uchar&gt;(3,3) &lt;&lt; 0,1,0,1,-4,1,0,1,0);</span><br></pre></td></tr></table></figure>
<p>上式创建的掩膜为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">-4</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>该卷积核可以用来提高对比度。又被成为<strong>拉普拉斯算子</strong></p>
<p><strong>sobel算子</strong>，可以用于检测边缘<br>
检测横向边缘：</p>
<table>
<thead>
<tr>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>-1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>检测纵向边缘</p>
<table>
<thead>
<tr>
<th>-1</th>
<th>-2</th>
<th>-1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="卷积">卷积</h3>
<p><kbd>filter2D()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void filter2D( InputArray src, OutputArray dst, int ddepth,InputArray kernel, Point anchor &#x3D; Point(-1,-1),double delta &#x3D; 0, int borderType &#x3D; BORDER_DEFAULT )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是图像深度, -1 代表与输入图像一致</p>
<p>第四个参数是卷积核</p>
<p>第五个参数是锚点</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter2D(image_in,image_out,-1,kernel);	&#x2F;&#x2F;使用kernel为卷积核输出image_out</span><br></pre></td></tr></table></figure>
<h3 id="模糊">模糊</h3>
<h4 id="均值模糊-均值滤波">均值模糊/均值滤波</h4>
<p><kbd>blur()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void blur( InputArray src, OutputArray dst,Size ksize, Point anchor &#x3D; Point(-1,-1),int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是均值模糊卷积核的大小，全方向模糊一般取3*3或5*5，也可以去单列或者单行的大小以进行单方向的模糊。要注意这个尺寸要确保有中心点存在。（2*2就不存在绝对的中心点）</p>
<p>第四个参数是锚点，默认位卷积核中心</p>
<p>第五个是边缘处理模式，一般用默认</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blur(image_in , image_out , Size(3,3));</span><br></pre></td></tr></table></figure>
<p>均值模糊无法保留边缘特征，只能整体模糊。</p>
<h4 id="中值模糊-中值滤波">中值模糊/中值滤波</h4>
<p><kbd>medianBlur()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void medianBlur( InputArray src, OutputArray dst, int ksize );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是卷积核的大小，固定是正方形，所以只取数字就可以，9就代表9*9的范围</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medianBlur(image_in , image_out , 3);</span><br></pre></td></tr></table></figure>
<p>中值滤波很适合去除椒盐噪声。</p>
<h4 id="高斯模糊-高斯滤波">高斯模糊/高斯滤波</h4>
<h5 id="高斯">高斯</h5>
<p><kbd>GaussianBlur()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GaussianBlur( InputArray src, OutputArray dst, Size ksize,double sigmaX, double sigmaY &#x3D; 0,int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是卷积核的大小</p>
<p>第四个参数是x方向上的标准偏差</p>
<p>第五个参数是y方向上的标准偏差</p>
<p>第六个参数是边缘处理模式</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GaussianBlur(image_in , image_out , Size(3,3) , 0.5 , 0.5);</span><br></pre></td></tr></table></figure>
<p>这种高斯模糊相较于均值模糊可以保留更多细节，但对边缘的保留一样效果不太好。</p>
<h5 id="双边高斯">双边高斯</h5>
<p><kbd>bilateralFilter()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bilateralFilter( InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace,int borderType &#x3D; BORDER_DEFAULT );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是过滤器的大小，太大的话会影响速度</p>
<p>第四个参数是色彩空间的sigma，大一点可以提高模糊效果</p>
<p>第五个参数是坐标空间的sigma，小一点可以提高边缘保留效果</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bilateralFilter(image_in , image_out , 5 , 150 , 3);</span><br></pre></td></tr></table></figure>
<p>模糊效果不错，而且可以保留边缘，对人脸处理时，有类似于磨皮的效果。</p>
<hr>
<h2 id="形态学操作">形态学操作</h2>
<h3 id="结构体">结构体</h3>
<p><kbd>getStructuringElement()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat getStructuringElement(int shape, Size ksize, Point anchor &#x3D; Point(-1,-1));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是结构体的形状</p>
<p>预设的形状有：MORPH_RECT 矩形  MORPH_CROSS 十字 MORPH_ELLIPSE 椭圆形</p>
<p>第二个参数是结构体的大小</p>
<p>第三个参数是锚点位置</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mat kernel &#x3D; getStructuringElement(MORPH_RECT , Size(3,3));</span><br></pre></td></tr></table></figure>
<h3 id="运算">运算</h3>
<p><kbd>morphologyEx()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void morphologyEx( InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,int borderType &#x3D; BORDER_CONSTANT,const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是操作模式</p>
<blockquote>
<p>操作模式有：</p>
<p>膨胀：MORPH_DILATE	锚点处像素值取结构体覆盖下的最大值  扩大亮处</p>
<p>腐蚀：MORPH_ERODE	锚点处像素值取结构体覆盖下的最小值  扩大暗处</p>
<p>开运算：MORPH_OPEN	先腐蚀再膨胀 去掉小亮斑</p>
<p>闭运算： MORPH_CLOSE	先膨胀再腐蚀    去掉小暗斑</p>
<p>顶帽： MORPH_TOPHAT 	原图像与开运算后的结果求差	可以观察开运算去除了哪些物体</p>
<p>黑帽： MORPH_BLACKHAT	原图像与闭运算后的结果求差	可以观察闭运算的效果</p>
<p>形态学梯度：MORPH_GRADIENT	膨胀后的图减去腐蚀后的图	可以得到图像大致的边缘</p>
</blockquote>
<p>第四个参数是结构体</p>
</blockquote>
<h3 id="检测直线-字符">检测直线/字符</h3>
<p>通过合理设置结构体，再经过开运算就可以检测直线或者字符</p>
<p>检测水平直线，就设置单行较长的结构体</p>
<p>检测竖直直线，就设置单列较长的结构体</p>
<p>检测较粗字符，可以设置正方形的结构体</p>
<hr>
<h2 id="阈值">阈值</h2>
<h3 id="阈值操作">阈值操作</h3>
<p><kbd>threshold()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threshold( InputArray src, OutputArray dst,double thresh, double maxval, int type );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是阈值</p>
<p>第四个参数是最大值</p>
<p>第五个参数是操作模式</p>
<blockquote>
<p>操作模式有：</p>
<p>二值化：THRESH_BINARY 	大于阈值为最大，小于阈值为0</p>
<p>反二值化： THRESH_BINARY_INV		大于阈值为0，小于阈值为最大</p>
<p>截断： THRESH_TRUNC		大于阈值的限制为阈值，小于阈值的保持不变</p>
<p>取零： THRESH_TOZERO		大于阈值的不变，小于阈值的为0</p>
<p>反取零： THRESH_TOZERO_INV		大于阈值的为0，小于阈值的不变</p>
<p>最大类间方差： THRESH_OTSU		通过统计学计算阈值，常用于分离物体与背景</p>
<p>自适应阈值： THRESH_TRIANGLE		根据不同区域自行计算阈值，更多时候用另一个API实现</p>
</blockquote>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">threshold(image_in , image_out , 150 , 255 , THRESH_TOZERO);</span><br></pre></td></tr></table></figure>
<p><kbd>adaptiveThreshold()</kbd>函数</p>
<p>自适应阈值操作</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void adaptiveThreshold( InputArray src, OutputArray dst,double maxValue, int adaptiveMethod,int thresholdType, int blockSize, double C );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是最大值</p>
<p>第四个参数是自适应类型</p>
<blockquote>
<p>平均值：ADAPTIVE_THRESH_MEAN_C 	邻域像素平均值减去C作为阈值</p>
<p>高斯值：ADAPTIVE_THRESH_GAUSSIAN_C		邻域像素通过高斯加权平均减去C，sigma值取决与邻域大小</p>
</blockquote>
<p>第五个参数是阈值操作模式，只能是THRESH_BINARY或者THRESH_BINARY_INV</p>
<p>第六个参数是计算阈值的邻域大小，3，5，7之类的</p>
<p>第七个参数是偏差值，可以设为0</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adaptiveThreshold(image_in , image_out , 255 , ADAPTIVE_THRESH_MEAN_C , THRESH_BINARY , 3 , 0);</span><br></pre></td></tr></table></figure>
<p>合理的设置阈值可以分离物体与背景，也可以用于获得物体的大致边缘。</p>
<h3 id="边缘检测">边缘检测</h3>
<p><kbd>Canny()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Canny( InputArray image, OutputArray edges,double threshold1, double threshold2, int apertureSize &#x3D; 3, bool L2gradient &#x3D; false );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出图像</p>
<p>第三个参数是阈值1	低于这个阈值的点被认为不是边缘</p>
<p>第四个参数是阈值2	高于这个阈值的点被认为是边缘，	处于1与2之间的点会检测是否与边缘点接触，若接触则为边缘点</p>
<p>第五个参数是邻域范围</p>
<p>第六个参数是 是否使用更加精确的计算方法</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Canny(image_in , image_out , 100 , 200 , 3 , ture);</span><br></pre></td></tr></table></figure>
<p>使用Canny前，要先进行滤波，提高效果</p>
<hr>
<h2 id="霍夫变换">霍夫变换</h2>
<h3 id="直线">直线</h3>
<p><kbd>HoughLinesP()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HoughLinesP( InputArray image, OutputArray lines,double rho, double theta, int threshold,double minLineLength &#x3D; 0, double maxLineGap &#x3D; 0 );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出的直线两个端点坐标</p>
<p>第三个参数是极坐标中像素的扫描步长</p>
<p>第四个参数是极坐标中角度的扫描步长，一般取 CV_PI/180 也就是一度</p>
<p>第五个参数是阈值，极坐标系中至少要多少个函数相交才会看作直线</p>
<p>第六个参数是直线的最小长度</p>
<p>第七个参数是直线延伸过程中最大的间隔</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Vec4f&gt; plines ;	&#x2F;&#x2F;设置一个向量用于存放输出</span><br><span class="line">HoughLinesP(image_in , plines , 1 , CV_PI&#x2F;180 , 20 , 50 , 5);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; plines.size(); i++)	&#x2F;&#x2F;划出直线</span><br><span class="line">	&#123;</span><br><span class="line">		Vec4f point &#x3D; plines[i];	&#x2F;&#x2F;取出第i个直线的端点数据，四个数据依次为，x0,y0,x1,y1</span><br><span class="line">		line(image_out, Point(point[0], point[1]), Point(point[2], point[3]), Scalar(255, 255, 0), 2, LINE_AA);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>要先进行Canny边缘检测再进行霍夫直线检测</p>
<h3 id="圆">圆</h3>
<p><kbd>HoughCircles()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HoughCircles( InputArray image, OutputArray circles,int method, double dp, double minDist, double param1 &#x3D; 100, double param2 &#x3D; 100,int minRadius &#x3D; 0, int maxRadius &#x3D; 0 );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像</p>
<p>第二个参数是输出数据</p>
<p>第三个参数是检测方法，只有CV_HOUGH_GRADIENT</p>
<p>第四个参数设为1</p>
<p>第五个参数是两个圆心之间的最小距离</p>
<p>第六个参数是Canny检测时的高阈值，低阈值默认为高阈值的一半</p>
<p>第七个参数是圆心的阈值，在极坐标系中至少多少个函数的交点会被认为是圆心</p>
<p>第八个参数是圆的最小半径</p>
<p>第九个参数是圆的最大半径</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Vec3f&gt; pcircles;		&#x2F;&#x2F;设置一个向量存储输出数据</span><br><span class="line">HoughCircles(image_in , pcircles , CV_HOUGH_GRADIENT , 1 , 100 , 120 , 50 , 100 , 200);</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; pcircles.size(); i++)	&#x2F;&#x2F;画出所有的圆，输出的数据中三个数据依次为x0,y0,r</span><br><span class="line">&#123;</span><br><span class="line">	Vec3f circles &#x3D; pcircles[i];</span><br><span class="line">circle(dst,Point(circles[0],circles[1]),circles[2],Scalar(0,0,255),1,LINE_AA);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>霍夫圆很容易受到椒盐噪声的影响，最好先进行中值滤波</p>
<hr>
<h2 id="直方图">直方图</h2>
<h3 id="直方图计算">直方图计算</h3>
<p><kbd>calcHist()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void calcHist( const Mat* images, int nimages,const int* channels, InputArray mask,SparseMat&amp; hist, int dims,const int* histSize, const float** ranges,bool uniform &#x3D; true, bool accumulate &#x3D; false );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的图像数组，也可以是单一图像的指针</p>
<p>第二个参数是图像的个数</p>
<p>第三个参数是通道数的地址，需要计算的通道的下标，可以传入一个数组，如果是单通道就是只有0的数组。</p>
<p>第四个参数是掩膜，如果有的话就是只计算掩膜上非零位置，不使用的话可以输cv::Mat()</p>
<p>第五个参数是输出的直方图数据</p>
<p>第六个参数是直方图的维度，一般来说取1</p>
<p>第七个参数是每一维上直方图个数的指针，一般来说越大直方图越精细</p>
<p>第八个参数是要统计的灰度范围，用一维float数组装入最小值与最大值，再装入一个常量float指针数组。</p>
<p>第九个参数是是否归一化，默认开启</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int channels &#x3D; 0;	&#x2F;&#x2F;设置通道数</span><br><span class="line">float range[] &#x3D; &#123;0,256&#125;;	&#x2F;&#x2F;将最小值与最大值存入一维float数组</span><br><span class="line">const float* histrange[] &#x3D; &#123;range&#125;;	&#x2F;&#x2F;将一维数组装入常量float指针数组</span><br><span class="line">int hist_size &#x3D; 200;	&#x2F;&#x2F;一共200个直方图</span><br><span class="line">calcHist(image_in , 1 , &amp;channels , Mat() , hist , 1 , &amp;hist_size , histrange);	&#x2F;&#x2F;将直方图数据存入hist</span><br><span class="line">normalize(hist , hist , 0 , image_out.rows , NORM_MINMIX);&#x2F;&#x2F;进行归一化</span><br><span class="line">double bin_w &#x3D; (double)image_out.rows&#x2F;hist_size;</span><br><span class="line">for (int i &#x3D; 1; i &lt; hist_size; i++)</span><br><span class="line">&#123;</span><br><span class="line">	line(image_out , Point((i-1)*bin_w , image_out.rows - cvRound(hist.at&lt;float&gt;(i-1))) , Point(i*bin_w , image_out.rows - cvRound(hist.at&lt;float&gt;(i))) , Scalar(255,0,0) , 2 , LINE_AA);</span><br><span class="line">&#125; &#x2F;&#x2F;cvRound是四舍五入取整</span><br></pre></td></tr></table></figure>
<p>计算出直方图后要对结果数组进行进行归一化，然后循环画出直方图。</p>
<h3 id="直方图对比">直方图对比</h3>
<p><kbd>compareHist()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double compareHist( InputArray H1, InputArray H2, int method );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入直方图1</p>
<p>第二个参数是输入直方图2</p>
<p>第三个参数是对比模式</p>
<blockquote>
<p>对比模式有：</p>
<p>相关性比较：CV_COMP_CORREL	概率论中的相关系数，绝对值为1时两图相同，为0时完全不相关</p>
<p>卡方比较： CV_COMP_CHISQR	返回值为0时两图相同，为1时两图无关</p>
<p>十字比较：CV_COMP_INTERSECT	取每个位置两者的最小值累加，不是很好用</p>
<p>巴氏距离：CV_COMP_BHATTACHARYYA	两图相同时为1，不相关时为0，相对而言效果最好</p>
</blockquote>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double compare_12 &#x3D; compareHist(hist_1 , hist_2 , CV_COMP_BHATTACHARYYA);</span><br></pre></td></tr></table></figure>
<p>直方图对图像灰度比较敏感，要做比较时，最好先将图像转到HVS空间再进行直方图计算，最后进行比较。HSV图像计算直方图时，需要计算的通道为第一和第二通道。</p>
<h3 id="直方图均衡化">直方图均衡化</h3>
<p><kbd>equalizeHist()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void equalizeHist( InputArray src, OutputArray dst );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入图像，需要是单通道</p>
<p>第二个参数是输出图像</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">equalizeHist(image_in , image_out);</span><br></pre></td></tr></table></figure>
<p>直方图均衡化可以提高不同光照下的图像效果，使画面呈现出更多细节，增强后续处理的效果。</p>
<h3 id="直方图反向映射">直方图反向映射</h3>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calcBackProject( const Mat* images, int nimages,const int* channels, const SparseMat&amp; hist, OutputArray backProject, const float** ranges,double scale &#x3D; 1, bool uniform &#x3D; true );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是图像的地址</p>
<p>第二个参数是图像个数</p>
<p>第三个参数是通道的角标数组</p>
<p>第四个参数是直方图</p>
<p>第五个参数是输出图像</p>
<p>第六个参数是计算范围，与直方图计算里的那个一样</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hist_size &#x3D; 180;	&#x2F;&#x2F;直方图个数</span><br><span class="line">float range[] &#x3D; &#123; 0 , 180 &#125;;	&#x2F;&#x2F;统计范围，这里使用的是HSV图像，所以是0-180</span><br><span class="line">const float* ranges[] &#x3D; &#123; range &#125;;</span><br><span class="line">int channels[2] &#x3D; &#123; 0,1 &#125;;	&#x2F;&#x2F;统计HSV图像的前两个通道</span><br><span class="line">calcHist(&amp;image_hsv, 1, channels, Mat(), image_hist, 1 , &amp;hist_size, ranges);	&#x2F;&#x2F;计算出直方图</span><br><span class="line">calcBackProject(&amp;image_hsv, 1, channels, image_hist, hist_back, ranges);	直方图反向映射</span><br></pre></td></tr></table></figure>
<h3 id="直方图匹配">直方图匹配</h3>
<p><kbd>matchTemplate()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void matchTemplate( InputArray image, InputArray templ,OutputArray result, int method, InputArray mask &#x3D; noArray() );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是待检测图像</p>
<p>第二个参数是用来检测的图像</p>
<p>第三个参数是输出图像</p>
<p>第四个参数是匹配模式</p>
<blockquote>
<p>匹配模式有：<br>
平方差匹配法：TM_SQDIFF</p>
<p>归一化平方差匹配法：TM_SQDIFF_NORMED	//这两个最佳匹配结果在0处</p>
<p>相关匹配法：TM_CCORR</p>
<p>归一化相关匹配法：TM_CCORR_NORMED	//这两个最佳匹配结果在最大处</p>
<p>系数匹配法：TM_CCOEFF</p>
<p>归一化相关系数匹配法：TM_CCOEFF_NORMED	//这两个最佳匹配结果在1，最差在-1，0为不相关</p>
<p>通常会使用归一化的匹配模式</p>
</blockquote>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matchTemplate(image_src, temp, temp_out, TM_CCOEFF_NORMED);	&#x2F;&#x2F;在image_src上寻找与temp图像匹配的部分，并把计算结果输出到temp_out中</span><br><span class="line">normalize(temp_out,temp_out, -1, 1, NORM_MINMAX); &#x2F;&#x2F;对输出的匹配结果进行归一化</span><br><span class="line">double MinVal &#x3D; 0, MaxVal &#x3D; 0;	&#x2F;&#x2F;用于存储匹配结果中的最大最小值	</span><br><span class="line">Point MinLoc(0, 0), MaxLoc(0, 0);	&#x2F;&#x2F;用于存储匹配结果中最大值与最小值的坐标</span><br><span class="line">minMaxLoc(temp_out, &amp;MinVal, &amp;MaxVal, &amp;MinLoc, &amp;MaxLoc);		&#x2F;&#x2F;寻找最值坐标</span><br><span class="line">circle(image_src, Point(MaxLoc.x + temp.cols &#x2F; 2, MaxLoc.y + temp.rows &#x2F; 2), 30, Scalar(0, 0, 255), 2, 8);	&#x2F;&#x2F;在原图上的最佳匹配点处画上圆，要注意如果是用平方差匹配要在最小值处画。</span><br></pre></td></tr></table></figure>
<h2 id="轮廓">轮廓</h2>
<h3 id="轮廓发现">轮廓发现</h3>
<p><kbd>findContours()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void findContours( InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode,int method, Point offset &#x3D; Point());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的图像，需要是完成Canny边缘检查的图像</p>
<p>第二个参数是输出的轮廓，包含多个轮廓，每个轮廓又包含很多的点，所以一般用vector&lt;vector(Point)&gt;类型的数据进行储存</p>
<p>第三个参数是拓扑信息，里边存储了每个轮廓与其他轮廓的拓扑关系，后一个轮廓 前一个轮廓 父轮廓 内嵌轮廓，一共四个相关轮廓的索引编号，所以一般用vector&lt;Vec4i&gt;进行储存，拓扑信息与每个轮廓一一对应</p>
<p>第四个参数是轮廓检索模式</p>
<blockquote>
<p>轮廓检索模式有：</p>
<p>只检测最外围轮廓： CV_RETR_EXTERNAL	内部轮廓被忽略</p>
<p>检测所有的轮廓： CV_RETR_LIST   检测所有轮廓但检测到的轮廓不建立等级关系，相互独立。所以不存在父轮廓和内嵌轮廓。拓扑信息的第三、四位默认为-1</p>
<p>检测所有的轮廓且建立两个等级关系：CV_RETR_CCOMP  不同轮廓间外围为顶层，如果内围轮廓内部也包括其他轮廓，则它也被视作顶层。</p>
<p>检测所有的轮廓且建立等级树： CV_RETR_TREE  会根据轮廓的关系建立等级树，外围包括内围，内围也可包括其他轮廓。</p>
</blockquote>
<p>第五个参数是轮廓的呈现方法</p>
<blockquote>
<p>呈现方法有：</p>
<p>获取每个轮廓的每个像素：CV_CHAIN_APPROX_NONE  将相互之间距离不超过1的点全部相连</p>
<p>只取轮廓的拐点像素：CV_CHAIN_APPROX_SIMPLE 对信息进行了压缩</p>
<p>teh-Chinl chain 近似算法：CV_CHAIN_APPROX_TC89_L1</p>
<p>CV_CHAIN_APPROX_TC89_KCOS</p>
</blockquote>
</blockquote>
<h3 id="轮廓绘制">轮廓绘制</h3>
<p><kbd>drawContours()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void drawContours( InputOutputArray image, InputArrayOfArrays contours,int contourIdx, const Scalar&amp; color, int thickness &#x3D; 1, int lineType &#x3D; LINE_8, InputArray hierarchy &#x3D; noArray(), int maxLevel &#x3D; INT_MAX, Point offset &#x3D; Point() );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是绘制的图像</p>
<p>第二个参数是输入的轮廓信息</p>
<p>第三个参数是轮廓的索引号</p>
<p>第七个参数是拓扑信息</p>
<p>第八个参数是最大层数，0代表只绘制当前 ，1代表绘制当前以及内嵌</p>
<p>第九个参数是每个点的偏移量，一般不设置</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvtColor(image_src, image_gray, CV_BGR2GRAY);</span><br><span class="line">Canny(image_gray, image_canny, 40, 140);</span><br><span class="line">Mat image_out(image_canny.size(),CV_8UC3);</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">findContours(image_canny, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);</span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">drawContours(image_out,contours,i,Scalar(255,0,0),1,LINE_AA,hierarchy);</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure>
<h3 id="凸包">凸包</h3>
<p><kbd>convexHull()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void convexHull( InputArray points, OutputArray hull, bool clockwise &#x3D; false, bool returnPoints &#x3D; true );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的轮廓数据</p>
<p>第二个参数是输出的凸包数据，数据类型与轮廓数据一样 vector&lt;vector&lt;Point&gt;&gt;</p>
<p>第三个参数是检测的方向，默认为逆时针</p>
<p>第四个参数是操作标识符，一般不用设置</p>
</blockquote>
<p>样例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours ;	&#x2F;&#x2F;用于存储轮廓数据</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;	&#x2F;&#x2F;用于存储轮廓的拓扑信息</span><br><span class="line">findContours(image_canny, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_TC89_KCOS);	&#x2F;&#x2F;发现轮廓</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt;	convex(contours.size());	&#x2F;&#x2F;用于存储凸包信息</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; contours.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">convexHull(contours[i], convex[i]);		&#x2F;&#x2F;检测凸包</span><br><span class="line">&#125;</span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">drawContours(image_out,convex,i,Scalar(0,0,0),2 , LINE_AA );	&#x2F;&#x2F;绘制凸包</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure>
<h3 id="绘制矩形-椭圆框">绘制矩形/椭圆框</h3>
<h4 id="压缩点集">压缩点集</h4>
<p><kbd>approxPolyDP()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void approxPolyDP( InputArray curve, OutputArray approxCurve,double epsilon, bool closed );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入点集，一般是轮廓数据</p>
<p>第二个参数是压缩后的点集</p>
<p>第三个参数是压缩精度，代表压缩后曲线与原曲线的最大距离</p>
<p>第四个参数是是否闭合，true是闭合</p>
</blockquote>
<h4 id="获得矩形">获得矩形</h4>
<h5 id="无角度">无角度</h5>
<p><kbd>boundingRect()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rect boundingRect( InputArray points );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数为点集</p>
</blockquote>
<p>返回值为Rect，所以一般用vector&lt;Rect&gt;进行储存</p>
<h5 id="倾斜">倾斜</h5>
<p><kbd>minAreaRect()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RotatedRect minAreaRect( InputArray points );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数为点集</p>
</blockquote>
<p>返回值为RotateRect，包含矩形的四个顶点。一般用vector&lt;RotateRect&gt;进行储存。</p>
<p>需要注意，这个函数对输入点集的个数有要求，至少要有四个点以上。</p>
<h4 id="获得圆">获得圆</h4>
<h5 id="圆形-2">圆形</h5>
<p><kbd>minEnclosingCircle()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void minEnclosingCircle( InputArray points, CV_OUT Point2f&amp; center, CV_OUT float&amp; radius );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入点集</p>
<p>第二个参数是圆心集合</p>
<p>第三个参数是半径集合</p>
</blockquote>
<h5 id="椭圆-2">椭圆</h5>
<p><kbd>fitEllipse()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RotatedRect fitEllipse( InputArray points );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数是输入点集</p>
</blockquote>
<p>返回值与旋转矩形一致，需要注意这个函数的输入点集至少要有六个点，使用时需要进行判断。</p>
<h4 id="样例代码">样例代码</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;拟合</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; approx(contours.size());		&#x2F;&#x2F;存储压缩后的点集</span><br><span class="line">vector&lt;Rect&gt; rect(contours.size());			&#x2F;&#x2F;存储拟合的无角度矩形</span><br><span class="line">vector&lt;RotatedRect&gt;	rotate(contours.size());		&#x2F;&#x2F;存储拟合的有角度矩形</span><br><span class="line">vector&lt;RotatedRect&gt;  elipse_(contours.size());		&#x2F;&#x2F;存储拟合的椭圆</span><br><span class="line">vector&lt;Point2f&gt; css(contours.size());		&#x2F;&#x2F;存储拟合圆的圆心</span><br><span class="line">vector&lt;float&gt; rad(contours.size());			&#x2F;&#x2F;存储拟合圆的半径</span><br><span class="line">for(int i&#x3D;0 ; i&lt;contours.size() ; i++)		&#x2F;&#x2F;遍历每一个轮廓点集</span><br><span class="line">&#123;</span><br><span class="line">	approxPolyDP(contours[i], approx[i], 3 , true);		&#x2F;&#x2F;压缩点集</span><br><span class="line">	rect[i] &#x3D; boundingRect(approx[i]);		&#x2F;&#x2F;拟合无角度矩形</span><br><span class="line">	rotate[i] &#x3D; minAreaRect(approx[i]);		&#x2F;&#x2F;拟合有角度矩形</span><br><span class="line">	minEnclosingCircle(approx[i], css[i], rad[i]);		&#x2F;&#x2F;拟合圆</span><br><span class="line">	if (approx[i].size() &gt; 5) &#123;			&#x2F;&#x2F;确保点集中至少六个点</span><br><span class="line">		elipse_[i] &#x3D; fitEllipse(approx[i]);		&#x2F;&#x2F;拟合椭圆</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制</span><br><span class="line"></span><br><span class="line">Point2f rotate_point[4];		&#x2F;&#x2F;用于取用拟合有角度矩形的四个顶点数据</span><br><span class="line">for (int i &#x3D; 0; i &lt; approx.size(); i++)		&#x2F;&#x2F;遍历每个轮廓进行绘制</span><br><span class="line">&#123;</span><br><span class="line">	rotate[i].points(rotate_point);		&#x2F;&#x2F;将顶点数据存入rotate_point</span><br><span class="line">	rectangle(image_src, rect[i], Scalar(0, 0, 0), 3, LINE_AA);			&#x2F;&#x2F;绘制无角度矩形</span><br><span class="line">	circle(image_src, css[i], rad[i], Scalar(100, 0, 100));			&#x2F;&#x2F;绘制圆</span><br><span class="line">	ellipse(image_src, elipse_[i], Scalar(0, 100, 100));		&#x2F;&#x2F;绘制椭圆</span><br><span class="line">	for (int k &#x3D; 0; k &lt; 4; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		line(image_src, rotate_point[k], rotate_point[(k+1)%4],Scalar(0,0,255));		&#x2F;&#x2F;使用四个顶点数据绘制旋转矩形，(k+1)%4是为了使矩形闭合且不超出边界</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图像矩以及轮廓面积-长度计算">图像矩以及轮廓面积/长度计算</h3>
<h4 id="图像矩">图像矩</h4>
<p><kbd>moments()</kbd>函数与类</p>
<p>通过轮廓数据计算中心距,可以用来拟合轮廓质心</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Moments moments( InputArray array, bool binaryImage &#x3D; false );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的轮廓数据</p>
<p>第二个参数是是否进行二值化，如果选true，灰度图中非零点均会被看作1</p>
</blockquote>
<p>返回值的数据类型为Moments类，一般用vector&lt;Moments&gt;进行储存。</p>
<h4 id="轮廓面积">轮廓面积</h4>
<p><kbd>contourArea()</kbd>函数</p>
<p>通过轮廓数据计算轮廓面积</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double contourArea( InputArray contour, bool oriented &#x3D; false );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的轮廓数据</p>
</blockquote>
<h4 id="轮廓长度">轮廓长度</h4>
<p><kbd>arcLength()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double arcLength( InputArray curve, bool closed );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入的轮廓数据</p>
<p>第二个参数是指定轮廓是否闭合</p>
</blockquote>
<h4 id="样例代码-2">样例代码</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;Moments&gt; moment(contours.size());	&#x2F;&#x2F;用于存储图像矩</span><br><span class="line">vector&lt;Point2f&gt; points(contours.size());	&#x2F;&#x2F;用于存储拟合的质心</span><br><span class="line"></span><br><span class="line">for(size_t i &#x3D; 0; i &lt; contours.size();i++)</span><br><span class="line">&#123; </span><br><span class="line">	drawContours(image_out, contours, i, Scalar(0, 0, 0), 2, LINE_AA);		&#x2F;&#x2F;绘制轮廓</span><br><span class="line">	moment[i] &#x3D; moments(contours[i]);	&#x2F;&#x2F;根据轮廓计算图像矩</span><br><span class="line">	contourArea(contours[i]);		&#x2F;&#x2F;根据轮廓计算面积</span><br><span class="line">	&#x2F;&#x2F;拟合质心，质心的x为图像矩的m10&#x2F;m00,y为图像矩的m01&#x2F;m00,static_cast是为了保证数据类型为float</span><br><span class="line">	points[i] &#x3D; Point(static_cast&lt;float&gt;(moment[i].m10 &#x2F; moment[i].m00), static_cast&lt;float&gt;(moment[i].m01 &#x2F; moment[i].m00));	</span><br><span class="line">	circle(image_out, points[i], 2, Scalar(255, 255, 0), 2);		&#x2F;&#x2F;绘制质心</span><br><span class="line">	cout &lt;&lt; &quot;轮廓&quot; &lt;&lt; i &lt;&lt; &quot;的面积为&quot; &lt;&lt; contourArea(contours[i]) &lt;&lt; endl &lt;&lt; &quot;长度为&quot; &lt;&lt; arcLength(contours[i],true)&lt;&lt;endl;		&#x2F;&#x2F;输出面积以及轮廓长度</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;image_out&quot;, image_out);</span><br></pre></td></tr></table></figure>
<h3 id="点多边形检测">点多边形检测</h3>
<p>用于检测点与封闭轮廓的位置关系</p>
<p><kbd>pointPolygonTest()</kbd>函数</p>
<p>函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pointPolygonTest( InputArray contour, Point2f pt, bool measureDist );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数是输入轮廓数据</p>
<p>第二个参数是检测点</p>
<p>第三个参数是设定是否要返回距离，如果是true则返回值为该点到轮廓的距离（外部为正，内部为负），如果为false，则返回值1、0、-1分别代表轮廓外，轮廓上、轮廓内</p>
</blockquote>
<h3 id="分水岭算法">分水岭算法</h3>
<p>用于分离图像上的不同部分</p>
<blockquote>
<p>这部分的代码 我一直编译失败，查了半天资料也没找出来问题，就先放下了，之后具体用到的时候再补上。</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:color_cat@126.com">colorcat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/">http://yoursite.com/2020/07/12/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94OpenCV%E5%B7%B2%E5%AD%A6API%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">瞎捣鼓的废宅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/">动态更新</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/">图像处理基础</a><a class="post-meta__tags" href="/tags/API%E6%B1%87%E6%80%BB/">API汇总</a></div><div class="post_share"><div class="social-share" data-image="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C/"><img class="next-cover" data-src="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图像处理基础学习笔记（二）——图像操作（Mat对象、读入、初始化、输出、点操作）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/30/科创项目-视觉追踪系统/" title="科创项目-视觉追踪系统"><img class="relatedPosts_cover" data-src="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-30</div><div class="relatedPosts_title">科创项目-视觉追踪系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/09/图像处理基础学习笔记（一）——图像处理简介/" title="图像处理基础学习笔记（一）——图像处理简介"><img class="relatedPosts_cover" data-src="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-09</div><div class="relatedPosts_title">图像处理基础学习笔记（一）——图像处理简介</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/09/图像处理基础学习笔记（二）——像素点操作/" title="图像处理基础学习笔记（二）——图像操作（Mat对象、读入、初始化、输出、点操作）"><img class="relatedPosts_cover" data-src="https://wx1.sbimg.cn/2020/07/03/2bjq1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-09</div><div class="relatedPosts_title">图像处理基础学习笔记（二）——图像操作（Mat对象、读入、初始化、输出、点操作）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC81MDgzOS8yNzMyMQ=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By colorcat</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>